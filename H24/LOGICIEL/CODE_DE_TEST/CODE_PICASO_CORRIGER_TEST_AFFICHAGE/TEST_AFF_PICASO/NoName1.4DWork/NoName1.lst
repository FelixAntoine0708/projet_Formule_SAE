file C:\Users\lvlg\Desktop\TEST_AFF_PICASO\NoName1.4dg

000001  000012  */
000002  000013        
000003  000014        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\uLCD-32PT.fnc

000004  000015  #platform "uLCD-32PT"
000005  000015  #platform "uLCD-32PT"
000006  000008  */
000007  000009      #constant ULCD_32PT_GFX
000008  000009      #constant ULCD_32PT_GFX
000009  000010        
000010  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000011  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000012  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000013  000001        
000014  000002  // Common inheritance for PicasoGFX2 platforms
000015  000003        
000016  000004  #constant PICASO_FUNCTIONS
000017  000004  #constant PICASO_FUNCTIONS
000018  000005        
000019  000006        
000020  000007  #CONST
000021  000017  #END
000022  000018        
000023  000019  #CONST
000024  000025  #END
000025  000026        
000026  000027        
000027  000028  #CONST
000028  000040  #END
000029  000041        
000030  000042        
000031  000043  #CONST
000032  000208  #END
000033  000209        
000034  000210        
000035  000211  // baud divisor rates for setbaud(n);
000036  000212  #CONST
000037  000234  #END
000038  000235        
000039  000236        
000040  000237        
000041  000238        
000042  000243  */
000043  000244        
000044  000245        
000045  000246  //==============================================//
000046  000247  // EVE bios functions                           //
000047  000248  //==============================================//
000048  000249                                                  //
000049  000250  func serin(), 1;                // read a byte from COM0
000050  000251  // Syntax: serin();
000051  000252  // Usage : char := serin();
000052  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000053  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000054  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000055  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000056  000257  //     : Returns: -1 if no character is available
000057  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000058  000259  //     : Returns: positive value 0 to 255 for a valid character received
000059  000260        
000060  000261  func putch("char"), 0;                // write single char to current output device
000061  000262  // Syntax: putch("char");
000062  000263  // Usage : putch("A");
000063  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000064  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000065  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000066  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000067  000268  //     : The arguments can be a variable, array element, expression or constant
000068  000269        
000069  000270  func serout("char"), 0;                // write a byte to COM0
000070  000271  // Syntax: serout1("char");
000071  000272  // Usage : serout1(ch);
000072  000273  // Notes : send character to COM1
000073  000274        
000074  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000075  000276  // Syntax: setbaud(baud_number);
000076  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000077  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000078  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000079  000280  //       : this is used as a table pointer to get the baud rate divisor
000080  000281  //       : value for one of the 20 selected baud rates, control is then
000081  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000082  000283  //       : The pre-defined constants equate to a value of 0-19.
000083  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000084  000285  //       : will occur.
000085  000286        
000086  000287  func to("device"), 1;                // output device redirection
000087  000288  // Syntax: to(outstream);
000088  000289  // Usage : to(APPEND); putstr("TWO ");
000089  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000090  000291  //     :
000091  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000092  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000093  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000094  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000095  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000096  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000097  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000098  000299  //     : sequential data to a media stream.
000099  000300  //     :
000100  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000101  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000102  000303  //     :                            appended to user memory if previous redirection was to an array.
000103  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000104  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000105  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000106  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000107  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000108  000309        
000109  000310        
000110  000311  func pause("milliseconds"), 0;            // blocking delay
000111  000312  // Syntax: pause(milliseconds);
000112  000313  // Usage : pause(1000);                //pause for 1 second
000113  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000114  000315        
000115  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000116  000317  // Syntax: putnum(format, value);
000117  000318  // Usage : var := putnum(HEX, val);
000118  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000119  000320  //     : Format: A constant that specifies the number format
000120  000321  //     : Value : The number to be printed
000121  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000122  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000123  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000124  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000125  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000126  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000127  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000128  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000129  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000130  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000131  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000132  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000133  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000134  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000135  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000136  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000137  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000138  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000139  000340  //     :
000140  000341  //     : bit 15 Leading spaces (1=space before signed number, 0=No space)
000141  000342  //     : bit 14 sign bit (0=signed, 1=unsigned)
000142  000343  //     : bit 13 Blanking (1=Leading zero blanking, 0=Show Zeros)
000143  000344  //     : bit 12 Leading zeros (1=Zeros included, 0=Zeros suppressed)
000144  000345  //     : bits 11-8 Displayed digit quantity
000145  000346  //     : bits 7-5 Reserved
000146  000347  //     : bits 4-0 Number base (usually 2,10 or 16)
000147  000348        
000148  000349        
000149  000350  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000150  000351        
000151  000352  func putstr("string"), 1;                       // print string to current output device
000152  000353  // Syntax: putstr(pointer);
000153  000354  // Usage : putstr("HELLO\n");
000154  000355  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000155  000356  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000156  000357  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000157  000358  //       : The output of putstr can be redirected to the communications port, the media, or memory
000158  000359  //       : using the to(...); function.
000159  000360  //       : A string constant is automatically terminated with a zero.
000160  000361  //       : A string in a data statement is not automatically terminated with a zero.
000161  000362  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000162  000363  //       : element packs 1 or 2 characters.
000163  000364        
000164  000365        
000165  000366  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000166  000367  // Syntax: strlen("varAddress);
000167  000368  // Usage : strlen("HELLO\n");
000168  000369  // Notes : gives the length of a string that is packed into regular var array
000169  000370  //       : Use str_Length(ptr)  for string pointer mode
000170  000371        
000171  000372        
000172  000373  //==============================================//
000173  000374  // Memory Access Function Prototypes            //
000174  000375  //==============================================//
000175  000376                                                  //
000176  000377  func peekW("address"), 1;                       // read a word from system memory
000177  000378  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000178  000379  // refer to address map of internal variables   //
000179  000380  //==============================================//
000180  000381  // Math Functions                               //
000181  000382  //==============================================//
000182  000383                                                  //
000183  000384  func ABS("value"), 1;                           // return a positive number
000184  000385  // Syntax: ABS(value);
000185  000386  // Usage : var := ABS(arg);
000186  000387  // Notes : Returns the absolute value of an argument
000187  000388        
000188  000389  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000189  000390  // Syntax: MIN(value1, value2);
000190  000391  // Usage : var := MIN(arg1, arg2);
000191  000392  // Notes : Returns the minimum of 2 arguments
000192  000393        
000193  000394  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000194  000395  // Syntax: MAX(value1, value2);
000195  000396  // Usage : var := MAX(arg1, arg2);
000196  000397  // Notes : Returns the maximum of 2 arguments
000197  000398        
000198  000399  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000199  000400  // Syntax: SWAP(&var1, &var2);
000200  000401  // Usage : SWAP(&var1, &var2);
000201  000402  // Notes : Swaps the contents of 2 variables or memory locations
000202  000403        
000203  000404  func SIN("angle"), 1;                           // return SIN of angle
000204  000405  // Syntax: SIN(angle);
000205  000406  // Usage : var := SIN(arg);
000206  000407  // Notes : Returns the sine in radians of an argument in degrees
000207  000408  //       : the returned value range is from 127 to -127. The real
000208  000409  //       : cosine values vary from 1.0 to -1.0 so appropriate
000209  000410  //       : scaling must be done in user code.
000210  000411        
000211  000412  func COS("angle"), 1;                           // return COS of angle
000212  000413  // Syntax: COS(angle);
000213  000414  // Usage : var := COS(arg);
000214  000415  // Notes : Returns the cosine in radians of an argument in degrees
000215  000416  //       : the returned value range is from 127 to -127. The real
000216  000417  //       : cosine values vary from 1.0 to -1.0 so appropriate
000217  000418  //       : scaling must be done in user code.
000218  000419        
000219  000420  func RAND(), 1;                                 // return a pseudo random number
000220  000421  // Syntax: RAND();
000221  000422  // Usage : var := RAND();
000222  000423  // Notes : Returns a random number between 0 and 0xFFFF.
000223  000424  //       : The random number generator must first be seeded
000224  000425  //       : by using the SEED(number) function.
000225  000426        
000226  000427  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000227  000428  // Syntax: SEED(number);
000228  000429  // Usage : SEED(arg);
000229  000430  // Notes : Seeds the random number generator.
000230  000431        
000231  000432  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000232  000433  // Syntax: OVF();
000233  000434  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000234  000435  //       : hiWord := OVF();
000235  000436  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000236  000437        
000237  000438  func SQRT("number"), 1;                         // return square root of a number
000238  000439  // Syntax: SQRT(number);
000239  000440  // Usage : SQRT(arg);
000240  000441  // Notes : Returns the integer square root of a number.
000241  000442  //------------------------------------------------------------------//
000242  000443  //          Text Related Function Prototypes
000243  000444  //------------------------------------------------------------------//
000244  000445        
000245  000446  func txt_MoveCursor("line", "column"), 0;
000246  000447  // Syntax: txt_SetCursor(line, column);
000247  000448  // Usage : txt_SetCursor(arg1, arg2);
000248  000449  // Notes : Moves the text Cursor to a new screen position set by
000249  000450  //       : line,column parameters.
000250  000451        
000251  000452  func txt_Set("mode", "value"), 0;
000252  000453  // Syntax: txt_Set(mode, value);
000253  000454  // Usage : txt_Set(arg1, arg2);
000254  000455  // Returns : Original value before the change
000255  000456  // Notes : Sets various text related parameters used by other functions
000256  000457  //       : This allows the features to be set programatically with a
000257  000458  //       : single function call.It is strongly recommended to use the
000258  000459  //       : pre-defined constants rather than the mode numbers.
000259  000460  //       : NB:- Although it is often required to be able to set text
000260  000461  //       : functions with a single function call for graphics engine
000261  000462  //       : related functions, there is a complete set of single parameter
000262  000463  //       : shortcut functions that have exactly the same function as
000263  000464  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000264  000465  //       :
000265  000466  //       : mode = TEXT_COLOUR (mode 0)
000266  000467  //       : txt_Set(TEXT_COLOUR, value);
000267  000468  //       : value = 0 to 0xFFFF, Black to White
000268  000469  //       : Sets the Text colour for the display
000269  000470  //       : Default = LIME.
000270  000471  //       :
000271  000472  //       : mode = TEXT_HIGHLIGHT (mode 1)
000272  000473  //       : txt_Set(TEXT_HIGHLIGHT, value);
000273  000474  //       : value = 0 to 0xFFFF, Black to White
000274  000475  //       : Sets the Text background colour for the display. Effective
000275  000476  //       : when text mode is Opaque.
000276  000477  //       : Default = BLACK.
000277  000478  //       :
000278  000479  //       : mode = FONT_ID (mode 2)
000279  000480  //       : txt_Set(FONT_ID, value);
000280  000481  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000281  000482  //       : else this value is the name of a font included
000282  000483  //       : in a users program in a data statement.
000283  000484  //       : Default = FONT SIZE 3.
000284  000485  //       :
000285  000486  //       : mode = TEXT_WIDTH  (mode 3)
000286  000487  //       : txt_Set(TEXT_WIDTH, value);
000287  000488  //       : value = 1 to 16
000288  000489  //       : Sets the Text Width multiplier
000289  000490  //       : text will be printed magnified horizontally
000290  000491  //       : by this factor, Default = 1.
000291  000492  //       :
000292  000493  //       : mode = TEXT_HEIGHT  (mode 4)
000293  000494  //       : txt_Set(TEXT_HEIGHT, value);
000294  000495  //       : value = 1 to 16
000295  000496  //       : Sets the Text Height multiplier
000296  000497  //       : text will be printed magnified vertically
000297  000498  //       : by this factor, Default = 1.
000298  000499  //       :
000299  000500  //       : mode = TEXT_XGAP  (mode 5)
000300  000501  //       : txt_Set(TEXT_XGAP, value);
000301  000502  //       : value = 1 to 32
000302  000503  //       : Sets the horizontal gap between characters
000303  000504  //       : The gap is in pixel units, Default = 0
000304  000505  //       :
000305  000506  //       : mode = TEXT_YGAP  (mode 6)
000306  000507  //       : txt_Set(TEXT_YGAP, value);
000307  000508  //       : value = 1 to 32
000308  000509  //       : Sets the vertical gap below characters
000309  000510  //       : The gap is in pixel units, Default = 0
000310  000511  //       :
000311  000512  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000312  000513  //       : txt_Set(TEXT_PRINTDELAY, value);
000313  000514  //       : value = 0 to 255
000314  000515  //       : Sets the delay time (in ms) during character
000315  000516  //       : printing to give a 'teletype' like effect.
000316  000517  //       : Often used to attract attention to a string
000317  000518  //       : being printed which can often be missed if
000318  000519  //       : just suddenly appearing or changing.
000319  000520  //       : Default = 0 ms.
000320  000521  //       :
000321  000522  //       : mode = TEXT_OPACITY (mode 8)
000322  000523  //       : txt_Set(TEXT_OPACITY, value);
000323  000524  //       : value = TRANSPARENT (0) = Text Trasparent
000324  000525  //       : value = OPAQUE (1) = Text Opaque
000325  000526  //       : Sets the Opacity/Transparency of the text
000326  000527  //       : Default = 0 or TRANSPARENT
000327  000528  //       :
000328  000529  //       : mode = TEXT_BOLD (mode 9)
000329  000530  //       : txt_Set(TEXT_BOLD, value);
000330  000531  //       : value = dont care
000331  000532  //       : Sets Bold Text mode for the next string or char
000332  000533  //       : The feature automatically resets after printing
000333  000534  //       : using putstr or print has completed
000334  000535  //       :
000335  000536  //       : mode = TEXT_ITALIC (mode 10)
000336  000537  //       : txt_Set(TEXT_ITALIC, value);
000337  000538  //       : value = dont care
000338  000539  //       : Sets Italic Text mode for the next string or char
000339  000540  //       : The feature automatically resets after printing
000340  000541  //       : using putstr or print has completed
000341  000542        
000342  000543  //       : mode = TEXT_INVERSE (mode 11)
000343  000544  //       : txt_Set(TEXT_INVERSE, value);
000344  000545  //       : value = dont care
000345  000546  //       : Sets Inverse Text mode for the next string or char
000346  000547  //       : The feature automatically resets after printing
000347  000548  //       : using putstr or print has completed
000348  000549  //       :
000349  000550  //       : mode = TEXT_UNDERLINED (mode 12)
000350  000551  //       : txt_Set(TEXT_UNDERLINED, value);
000351  000552  //       : value = dont care
000352  000553  //       : Sets Underlined Text mode for the next string or char
000353  000554  //       : The feature automatically resets after printing
000354  000555  //       : using putstr or print has completed
000355  000556  //       :
000356  000557  //       : mode = TEXT_ATTRIBUTES (mode 13)
000357  000558  //       : txt_Set(TEXT_ATTRIBUTES, value);
000358  000559  //       : value = bits are defined as:
000359  000560  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000360  000561  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000361  000562  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000362  000563  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000363  000564  //       : Allows a combination of text attributes to be defined together
000364  000565  //       : by 'or'ing the bits together.
000365  000566  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000366  000567  //       : The feature automatically resets after printing
000367  000568  //       : using putstr or print has completed.
000368  000569  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000369  000570  //       :
000370  000571  //       : mode = TEXT_WRAP (mode 14)
000371  000572  //       : txt_Set(TEXT_WRAP , value);
000372  000573  //       : Sets the position where text wrap will occur
000373  000574  //       : The feature automatically resets when screen
000374  000575  //       : mode is changed. If the value is set to 0,
000375  000576  //       : text wrap is turned off.
000376  000577  //       : of the current screen. Default value is 0
000377  000578  // Notes : The value is in pixel units.
000378  000579  //       :
000379  000580        
000380  000581  //       : txt_Set mode 15 reserved for future use
000381  000582  //       :
000382  000583        
000383  000584        
000384  000585        
000385  000586  //=====================================================//
000386  000587  // Single parameter short-cuts                         //
000387  000588  // for the txt_Set functions                           //
000388  000589  // These functions return the existing value before    //
000389  000590  // the change is made.                                 //
000390  000591  //=====================================================//
000391  000592  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000392  000593  func txt_BGcolour("colour"), 1;             // 1  text background colour
000393  000594  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000394  000595  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000395  000596  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000396  000597  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000397  000598  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000398  000599  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000399  000600  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000400  000601  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000401  000602  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000402  000603  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000403  000604  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000404  000605  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000405  000606  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000406  000607  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000407  000608        
000408  000609        
000409  000610  //------------------------------------------------------------------//
000410  000611  //                 Hardware Function Prototypes
000411  000612  //------------------------------------------------------------------//
000412  000613        
000413  000614  // I/O Pin reference:-
000414  000615  //
000415  000616  //    IO1_PIN           is pin 2 of J1
000416  000617  //    IO2_PIN           is pin 1 of J1
000417  000618  //    IO3_PIN           is pin 3 of J1
000418  000619  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000419  000620  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000420  000621  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000421  000622  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000422  000623  //    BUS_0             is pin 27 of J1
000423  000624  //    BUS_1             is pin 25 of J1
000424  000625  //    BUS_2             is pin 23 of J1
000425  000626  //    BUS_3             is pin 21 of J1
000426  000627  //    BUS_4             is pin 19 of J1
000427  000628  //    BUS_5             is pin 17 of J1
000428  000629  //    BUS_6             is pin 13 of J2
000429  000630  //    BUS_7             is pin 11 of J2
000430  000631  //    BACKLITE          is backlite control pin
000431  000632  //    AUDIO_ENABLE      is amplifier chip control pin
000432  000633        
000433  000634  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000434  000635  // Syntax: pin_Set(mode, pin);
000435  000636  // Usage : pin_Set(arg1, arg2);
000436  000637  // Notes : Sets the appropriate pins to Inputs or Outputs
000437  000638  //       : returns true if the pin number is legal (usually ignored)
000438  000639  //       :
000439  000640  //       : mode = 0 : Set Pin to Output
000440  000641  //       : pin_Set(0, pin);
000441  000642  //       : pin_Set(OUTPUT, pin);
000442  000643  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000443  000644  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000444  000645  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000445  000646  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000446  000647  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000447  000648  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000448  000649  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000449  000650  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000450  000651  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000451  000652  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000452  000653  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000453  000654  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000454  000655  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000455  000656  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000456  000657  //       : Sets the desired pin to be used as an Output.
000457  000658  //       :
000458  000659  //       : mode = 1 : Set Pin to Input
000459  000660  //       : pin_Set(1, pin);
000460  000661  //       : pin_Set(INPUT, pin);
000461  000662  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000462  000663  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000463  000664  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000464  000665  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000465  000666  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000466  000667  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000467  000668  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000468  000669  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000469  000670  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000470  000671  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000471  000672  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000472  000673  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000473  000674  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000474  000675  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000475  000676  //       : Sets the desired pin to be used as an Input.
000476  000677        
000477  000678  func pin_HI("pin"), 1;                    // set pin to logic '1'
000478  000679  // Syntax: pin_HI(pin);
000479  000680  // Usage : pin_HI(arg);
000480  000681  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000481  000682  //       : pin that was previously selected as an Output.
000482  000683  //       : returns true if the pin number is legal (usually ignored)
000483  000684  //       :
000484  000685  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000485  000686  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000486  000687  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000487  000688  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000488  000689  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000489  000690  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000490  000691  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000491  000692  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000492  000693  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000493  000694  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000494  000695  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000495  000696  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000496  000697  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000497  000698  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000498  000699  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000499  000700        
000500  000701  func pin_LO("pin"), 1;                    // set pin to logic '0'
000501  000702  // Syntax: pin_LO(pin);
000502  000703  // Usage : pin_LO(arg);
000503  000704  // Notes : Outputs a logic "Low" (0V) on the appropriate
000504  000705  //       : pin that was previously selected as an Output.
000505  000706  //       : returns true if the pin number is legal (usually ignored)
000506  000707  //       :
000507  000708  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000508  000709  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000509  000710  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000510  000711  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000511  000712  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000512  000713  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000513  000714  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000514  000715  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000515  000716  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000516  000717  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000517  000718  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000518  000719  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000519  000720  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000520  000721  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000521  000722  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000522  000723        
000523  000724  func pin_Read("pin"), 1;                // read pin, logic or analogue
000524  000725  // Syntax: pin_Read(pin);
000525  000726  // Usage : arg1 := pin_Read(arg2);
000526  000727  // Notes : Reads the logic state of the appropriate
000527  000728  //       : pin that was previously selected as an Input.
000528  000729  //       :
000529  000730  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000530  000731  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000531  000732  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000532  000733  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000533  000734  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000534  000735  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000535  000736  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000536  000737  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000537  000738  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000538  000739  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000539  000740  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000540  000741  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000541  000742  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000542  000743  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000543  000744  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000544  000745  //       : Returns a 0 (logic low) or 1 (logic high).
000545  000746        
000546  000747        
000547  000748  //------------------------------------------------------------------//
000548  000749  //                 P1 module BUS I/O control
000549  000750  //------------------------------------------------------------------//
000550  000751        
000551  000752  func bus_In(), 1;
000552  000753  // Syntax: bus_In();
000553  000754  // Usage : arg1 := bus_In();
000554  000755  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000555  000756  //       : The upper 8 bits of arg1 are set to 0.
000556  000757  //       : the BUS_RD and BUS_WR pins are not affected.
000557  000758  //       :
000558  000759  //       : BUS_0 is pin 27 of J1
000559  000760  //       : BUS_1 is pin 25 of J1
000560  000761  //       : BUS_2 is pin 23 of J1
000561  000762  //       : BUS_3 is pin 21 of J1
000562  000763  //       : BUS_4 is pin 19 of J1
000563  000764  //       : BUS_5 is pin 17 of J1
000564  000765  //       : BUS_6 is pin 13 of J2
000565  000766  //       : BUS_7 is pin 11 of J2
000566  000767        
000567  000768  func bus_Out("var"), 0;
000568  000769  // Syntax: bus_Out(var);
000569  000770  // Usage : bus_Out(arg1);
000570  000771  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000571  000772  //       : The upper 8 bits of arg1 are ignored.
000572  000773  //       : the BUS_RD and BUS_WR pins are not affected.
000573  000774  //       : NB:- any BUS pins that are set to inputs are not affected.
000574  000775  //       :
000575  000776  //       : BUS_0 is pin 27 of J1
000576  000777  //       : BUS_1 is pin 25 of J1
000577  000778  //       : BUS_2 is pin 23 of J1
000578  000779  //       : BUS_3 is pin 21 of J1
000579  000780  //       : BUS_4 is pin 19 of J1
000580  000781  //       : BUS_5 is pin 17 of J1
000581  000782  //       : BUS_6 is pin 13 of J2
000582  000783  //       : BUS_7 is pin 11 of J2
000583  000784        
000584  000785  func bus_Set("var"), 0;
000585  000786  // Syntax: bus_Set(var);
000586  000787  // Usage : bus_Set(arg1);
000587  000788  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000588  000789  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000589  000790  //       : The upper 8 bits of arg1 are ignored.
000590  000791  //       : the BUS_RD and BUS_WR pins are not affected.
000591  000792  //       :
000592  000793  //       : BUS_0 is pin 27 of J1
000593  000794  //       : BUS_1 is pin 25 of J1
000594  000795  //       : BUS_2 is pin 23 of J1
000595  000796  //       : BUS_3 is pin 21 of J1
000596  000797  //       : BUS_4 is pin 19 of J1
000597  000798  //       : BUS_5 is pin 17 of J1
000598  000799  //       : BUS_6 is pin 13 of J2
000599  000800  //       : BUS_7 is pin 11 of J2
000600  000801        
000601  000802  func bus_Write("var"), 0;
000602  000803  // Syntax: bus_Write(var);
000603  000804  // Usage : bus_Write(arg1);
000604  000805  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000605  000806  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000606  000807  //       : LO for approx 50nsec then set back HI.
000607  000808  //       : The upper 8 bits of arg1 are ignored.
000608  000809  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000609  000810  //       : ensure BUS write integrity.
000610  000811  //       :
000611  000812  //       : BUS_0 is pin 27 of J1
000612  000813  //       : BUS_1 is pin 25 of J1
000613  000814  //       : BUS_2 is pin 23 of J1
000614  000815  //       : BUS_3 is pin 21 of J1
000615  000816  //       : BUS_4 is pin 19 of J1
000616  000817  //       : BUS_5 is pin 17 of J1
000617  000818  //       : BUS_6 is pin 13 of J2
000618  000819  //       : BUS_7 is pin 11 of J2
000619  000820        
000620  000821  func bus_Read(), 1;
000621  000822  // Syntax: bus_Read();
000622  000823  // Usage : arg1 := bus_Read();
000623  000824  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000624  000825  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000625  000826  //       : (the upper 8 bits being set to 0)
000626  000827  //       : the BUS_RD pin is then set back to a HI level.
000627  000828  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000628  000829  //       : ensure BUS write integrity.
000629  000830  //       :
000630  000831  //       : BUS_0 is pin 27 of J1
000631  000832  //       : BUS_1 is pin 25 of J1
000632  000833  //       : BUS_2 is pin 23 of J1
000633  000834  //       : BUS_3 is pin 21 of J1
000634  000835  //       : BUS_4 is pin 19 of J1
000635  000836  //       : BUS_5 is pin 17 of J1
000636  000837  //       : BUS_6 is pin 13 of J2
000637  000838  //       : BUS_7 is pin 11 of J2
000638  000839        
000639  000840        
000640  000841  //------------------------------------------------------------------//
000641  000842  //   Graphics Functions
000642  000843  //------------------------------------------------------------------//
000643  000844  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000644  000845  // Syntax: gfx_Set(mode, value);
000645  000846  // Usage : gfx_Set(arg1, arg2);
000646  000847  // Notes : Sets various graphics parameters used by other functions
000647  000848  //       : This allows the features to be set programatically with a
000648  000849  //       : single function call.It is strongly recommended to use the
000649  000850  //       : pre-defined constants rather than the mode numbers.
000650  000851  //       : NB:- Although it is often required to be able to set graphics
000651  000852  //       : functions with a single function call for graphics engine
000652  000853  //       : related functions, there is a complete set of single parameter
000653  000854  //       : shortcut functions that have exactly the same function as
000654  000855  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000655  000856  //       :
000656  000857  //       : mode = PEN_SIZE (mode 16)
000657  000858  //       : gfx_Set(PEN_SIZE, value);
000658  000859  //       : value = SOLID (value 0) rectangle and circle objects are solid
000659  000860  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000660  000861  //       : Sets the mode of the Pen used by most graphics objects
000661  000862  //       :
000662  000863  //       : mode = BACKGROUND_COLOUR (mode 17)
000663  000864  //       : gfx_Set(BACKGROUND_COLOUR, value);
000664  000865  //       : value = 0 to 0xFFFF, Black to White
000665  000866  //       : Sets the Background colour of the screen
000666  000867  //       :
000667  000868  //       : mode = OBJECT_COLOUR (mode 18)
000668  000869  //       : gfx_Set(OBJECT_COLOUR, value);
000669  000870  //       : value = 0 to 0xFFFF, Black to White
000670  000871  //       : Sets the Object colour used in various functions
000671  000872  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000672  000873  //       :
000673  000874  //       : mode = CLIPPING (mode 19)
000674  000875  //       : gfx_Set(CLIPPING, value);
000675  000876  //       : value = OFF (value 0) Clipping disabled
000676  000877  //       : value = ON (value 1) Clipping enabled
000677  000878  //       : Enables/Disables the Clipping feature
000678  000879  //       :
000679  000880  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000680  000881  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000681  000882  //       : value = 0 to 0xFFFF Black to White
000682  000883  //       : Sets Bitmap, Image or Animation Transparency Colour.
000683  000884  //       : NB not implemented
000684  000885  //       :
000685  000886  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000686  000887  //       : gfx_Set(5, value);
000687  000888  //       : value = OFF (value 0) Transparency disabled
000688  000889  //       : value = ON (value 1) Transparency enabled
000689  000890  //       : Enables/Disables the Transparency feature
000690  000891  //       : NB not implemented
000691  000892  //       :
000692  000893  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000693  000894  //       : gfx_Set(FRAME_DELAY, value);
000694  000895  //       : value = 0 to 65535 ms
000695  000896  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000696  000897  //       : over-ride the embedded frame delay of the clip. After the event,
000697  000898  //       : the setting will auto disable and if further inter-frame delays need
000698  000899  //       : overriding the setting must be re-issued.
000699  000900  //       :
000700  000901  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000701  000902  //       : gfx_Set(SCREEN_MODE, value);
000702  000903  //       : value = LANDSCAPE   (value 0)
000703  000904  //       : value = LANDSCAPE_R (value 1)
000704  000905  //       : value = PORTRAIT    (value 2)
000705  000906  //       : value = PORTRAIT_R  (value 3)
000706  000907  //       :
000707  000908  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000708  000909  //       : gfx_Set(OUTLINE_COLOUR, value);
000709  000910  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000710  000911  //       : Sets the filled Rectangle or Circle objects outline colour
000711  000912  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000712  000913  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000713  000914  //       :
000714  000915  //       : Only supports variable contrast for uOLED Modules
000715  000916  //       : mode = CONTRAST (mode 25) : Contrast
000716  000917  //       : gfx_Set(CONTRAST, value);
000717  000918  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000718  000919  //       : when contrast=0, display is placed in low power mode.
000719  000920  //       : This function should be called with contrast=0 when
000720  000921  //       : powering down the module.
000721  000922  //       :
000722  000923  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000723  000924  //       : gfx_Set(LINE_PATTERN, value);
000724  000925  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000725  000926  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000726  000927  //       : a value of 0 turns the feature off
000727  000928  //       :
000728  000929  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000729  000930  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000730  000931  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000731  000932  //       : NB not implemented, default is COLOUR16
000732  000933  //       :
000733  000934  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000734  000935  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000735  000936  //       : sets the button and slider objects bevel width
000736  000937  //       :
000737  000938  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000738  000939  //       : gfx_Set(BEVEL_SHADOW , 5);
000739  000940  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000740  000941  //       :
000741  000942  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000742  000943  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000743  000944  //       : sets the origin of drawn objects to a position other than 0,0
000744  000945  //       :
000745  000946  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000746  000947  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000747  000948  //       : sets the origin of drawn objects to a position other than 0,0
000748  000949        
000749  000950        
000750  000951  func gfx_Cls(), 0;                    // clear the screen
000751  000952  // Syntax: gfx_Cls();
000752  000953  // Usage : gfx_Cls();
000753  000954  // Notes : Clears the screen with current background colour
000754  000955        
000755  000956  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000756  000957  // Syntax: gfx_MoveTo(x, y);
000757  000958  // Usage : gfx_MoveTo(arg1, arg2);
000758  000959  // Notes : Moves the origin to a new x,y position
000759  000960        
000760  000961  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000761  000962  // Syntax: gfx_MoveRel(x, y);
000762  000963  // Usage : gfx_MoveRel(arg1, arg2);
000763  000964  // Notes : Moves the origin to a new x,y position
000764  000965  //       : relative to the current origing
000765  000966        
000766  000967  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000767  000968  // Syntax: gfx_LineTo(x1, y1);
000768  000969  // Usage : gfx_LineTo(arg1, arg2);
000769  000970  // Notes : Draws a Line from the origin x,y to x1,y1.
000770  000971  //       : The new origin is then set to x1, y1. Line colour needs
000771  000972  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000772  000973        
000773  000974  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000774  000975  // Syntax: gfx_LineRel(x1, y1);
000775  000976  // Usage : gfx_LineRel(arg1, arg2);
000776  000977  // Notes : Draws a Line from the origin x,y to x1,y1.
000777  000978  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000778  000979  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000779  000980        
000780  000981  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000781  000982  // Syntax: gfx_Line(x1, x2, y2, colr);
000782  000983  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000783  000984  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000784  000985        
000785  000986  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000786  000987  // Syntax: gfx_Line(x1, x2, y, colr);
000787  000988  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000788  000989  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000789  000990        
000790  000991  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000791  000992  // Syntax: gfx_Line(y1, y2, x, colr);
000792  000993  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000793  000994  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000794  000995        
000795  000996  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000796  000997  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000797  000998  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000798  000999  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000799  001000  //       : bottom corner (x2,y2) on the screen.
000800  001001        
000801  001002  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000802  001003  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000803  001004  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000804  001005  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000805  001006  //       : bottom corner (x2,y2) on the screen.
000806  001007        
000807  001008  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000808  001009  // Syntax: gfx_Circle(x, y, rad, colr);
000809  001010  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000810  001011  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000811  001012        
000812  001013  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000813  001014  // Syntax: gfx_Circle(x, y, rad, colr);
000814  001015  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000815  001016  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000816  001017        
000817  001018  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000818  001019  // Syntax: gfx_PutPixel(x, y, colr);
000819  001020  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000820  001021  // Notes : Plots a coloured pixel on the screen at x,y location
000821  001022        
000822  001023  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000823  001024  // Syntax: gfx_GetPixel(x, y);
000824  001025  // Usage : var := gfx_GetPixel(arg1, arg2);
000825  001026  // Notes : Reads and returns the colour value of a pixel at location x,y
000826  001027        
000827  001028  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000828  001029  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000829  001030  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000830  001031  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000831  001032  //       : Vertices must be specified in an anti-clockwise fashion
000832  001033        
000833  001034  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000834  001035  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000835  001036  // Usage : gfx_OrbitInit(&arg1, &arg2);
000836  001037  // Notes : Sets up the Orbit function parameters.
000837  001038  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000838  001039  //       : variables that get updated after calling gfx_Orbit(,,) function.
000839  001040  //       : The coordiantaes are calculated relative to the origin
000840  001041  //       : obtained by using the gfx_MoveTo(x, y) function.
000841  001042        
000842  001043  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000843  001044  // Syntax: gfx_Orbit(angle, distance);
000844  001045  // Usage : gfx_Orbit(arg1, arg2);
000845  001046  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000846  001047  //       : only known parameters are the angle and the distance from the current origin.
000847  001048        
000848  001049  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000849  001050  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000850  001051  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000851  001052  // Notes : This function is very similar to the Ploygon function
000852  001053  //       : with the exception of the 1st and the last vertices not joined.
000853  001054        
000854  001055  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000855  001056  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000856  001057  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000857  001058  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000858  001059  //       : Vertices must be minimum of 3 and can be specified in any fashion
000859  001060        
000860  001061  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000861  001062  // Syntax: gfx_Dot();
000862  001063  // Usage : gfx_Dot();
000863  001064  // Notes : Places a coloured dot at the origin
000864  001065        
000865  001066        
000866  001067  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000867  001068  // Syntax: gfx_Bullet();
000868  001069  // Usage : gfx_Bullet();
000869  001070  // Notes : Places a coloured circle at the origin
000870  001071  //       : filled or unfilled state is controlled by PenSize
000871  001072        
000872  001073  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000873  001074  // Syntax: gfx_IncX();
000874  001075  // Usage : var := gfx_IncX();
000875  001076  // Notes : Increments the x coordinate of the origin
000876  001077        
000877  001078  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000878  001079  // Syntax: gfx_IncY();
000879  001080  // Usage : var := gfx_IncY();
000880  001081  // Notes : Increments the y coordinate of the origin
000881  001082        
000882  001083  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000883  001084  // Syntax: gfx_BoxTo(x1, y1);
000884  001085  // Usage : gfx_BoxTo(arg1, arg2);
000885  001086  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000886  001087  //       : The new origin is then set to x1,y1. Rectangle colour needs
000887  001088  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000888  001089  //       : and the PenSize setting determines if Box is solid or outline.
000889  001090        
000890  001091  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000891  001092  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000892  001093  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000893  001094  // Notes : Specifies a clipping window region on the screen such that any objects
000894  001095  //       : and text placed onto the screen will be clipped and displayed only
000895  001096  //       : within that region. For the clipping window to take effect, "Clipping"
000896  001097  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000897  001098        
000898  001099        
000899  001100  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000900  001101  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000901  001102  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000902  001103  // *Notes:
000903  001104        
000904  001105  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000905  001106  // Syntax: gfx_SetClipRegion();
000906  001107  // Usage : var := gfx_SetClipRegion();
000907  001108  // *Notes:
000908  001109        
000909  001110  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000910  001111  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000911  001112  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000912  001113  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000913  001114  //       : with xradius = xrad and yradius = yrad.
000914  001115  //       : if PenSize = 0 Ellipse is Solid
000915  001116  //       : if PenSize = 1 Ellipse is Outline
000916  001117        
000917  001118        
000918  001119  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000919  001120  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000920  001121  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000921  001122  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000922  001123  //       : with xradius = xrad and yradius = yrad.
000923  001124        
000924  001125  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000925  001126  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000926  001127  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000927  001128  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000928  001129  //       : x,y arguments (top left corner). The size of the button depends on
000929  001130  //       : the font, width, height and length of the text.
000930  001131  //       : The button appearance will depend on the state parameter setting:
000931  001132  //       :         state = 0 : Button Pressed
000932  001133  //       :         state = 1 : Button Raised
000933  001134        
000934  001135  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000935  001136  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000936  001137  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000937  001138  // Notes : Draws a panel (groupbox) at screen location defined by
000938  001139  //       : x, y, width and height with colour "colour".
000939  001140  //       :         state = 0 : recessed
000940  001141  //       :         state = 1 : raised
000941  001142        
000942  001143  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000943  001144  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000944  001145  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000945  001146  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000946  001147  //       : Slider parameters are as follows:
000947  001148  //       :         mode = 0 : Slider recessed
000948  001149  //       :         mode = 1 : Slider raised
000949  001150  //       :         x1, y1 = top left corner
000950  001151  //       :         x2, y2 = bottom right corner
000951  001152  //       :         scale = n : sets the full scale range from 0 to n
000952  001153  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000953  001154  //       : returns:-
000954  001155        
000955  001156        
000956  001157  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000957  001158  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000958  001159  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000959  001160  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000960  001161  //       : and pastes it to another location determined by xd, yd.
000961  001162        
000962  001163  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000963  001164  // Syntax: gfx_RGBto565(red, green, blue);
000964  001165  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000965  001166  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000966  001167        
000967  001168  func gfx_332to565("COLOUR8BIT"), 1;
000968  001169  // Syntax: gfx_332to565(colour);
000969  001170  // Usage : gfx_332to565(arg);
000970  001171  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000971  001172        
000972  001173  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000973  001174  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000974  001175  // Usage : gfx_Selection(1, RED, YELLOW);
000975  001176  // Notes : Called prior to drawing a button, this function
000976  001177  //       : hilites the required text line on a multiline button.
000977  001178        
000978  001179  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000979  001180  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000980  001181  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000981  001182  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000982  001183  //       : Vertices must be specified in an anti-clockwise fashion
000983  001184        
000984  001185        
000985  001186  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000986  001187  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000987  001188  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
000988  001189  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000989  001190  //       : Vertices must be minimum of 3 and can be specified in any fashion
000990  001191        
000991  001192        
000992  001193  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
000993  001194  // Syntax: gfx_Offset(x, y);
000994  001195  // Usage : gfx_Offset(arg1, arg2);
000995  001196  // Notes : Set the screen offset
000996  001197        
000997  001198        
000998  001199        
000999  001200  func gfx_Get("mode"), 1;
001000  001201  // Syntax: gfx_Get(mode);
001001  001202  // Usage : arg1 := gfx_Get(arg);
001002  001203  // Notes : Returns various parameters to caller
001003  001204  //       :
001004  001205  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001005  001206  //       : var := gfx_Get(X_MAX);
001006  001207  //       : Returns the maximum horizontal value of the display
001007  001208  //       :
001008  001209  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001009  001210  //       : var := gfx_Get(Y_MAX);
001010  001211  //       : Returns the maximum vertical value of the display
001011  001212  //       :
001012  001213  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001013  001214  //       : var := gfx_Get(LEFT_POS);
001014  001215  //       : Returns the left location of the last drawn object
001015  001216  //       : such as a slider or button or an image/video
001016  001217  //       :
001017  001218  //       : mode = TOP_POS (mode 3) : Top location of Object
001018  001219  //       : var := gfx_Get(TOP_POS);
001019  001220  //       : Returns the top location of the last drawn object
001020  001221  //       : such as a slider or button or an image/video
001021  001222  //       :
001022  001223  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001023  001224  //       : var := gfx_Get(RIGHT_POS);
001024  001225  //       : Returns the right location of the last drawn object
001025  001226  //       : such as a slider or button or an image/video
001026  001227  //       :
001027  001228  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001028  001229  //       : var := gfx_Get(BOTTOM_POS );
001029  001230  //       : Returns the bottom location of the last drawn object
001030  001231  //       : such as a slider or button or an image/video
001031  001232  //       :
001032  001233        
001033  001234        
001034  001235  //==================================================//
001035  001236  // Single parameter short-cuts                      //
001036  001237  // for the gfx_Set functions                        //
001037  001238  // These functions return the existing value before //
001038  001239  // the change is made.                              //
001039  001240  //==================================================//
001040  001241  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001041  001242  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001042  001243  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001043  001244  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001044  001245  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001045  001246  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001046  001247  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001047  001248  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001048  001249  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001049  001250  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001050  001251  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001051  001252  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001052  001253  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001053  001254  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001054  001255  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001055  001256  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001056  001257        
001057  001258        
001058  001259  //==================================================//
001059  001260  // uSD/FLASH Function Prototypes                    //
001060  001261  //==================================================//
001061  001262  func media_Video("x", "y"), 0;                      // display movie at position x y
001062  001263  // Syntax: media_Video(x, y);
001063  001264  // Usage : media_Video(arg1, arg2);
001064  001265  // Notes : Play a Video/Animation clip from the uSD card at screen location
001065  001266  //       : specified by x,y (top left corner). The location of the clip in the
001066  001267  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001067  001268        
001068  001269  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001069  001270  // Syntax: media_VideoFrame(Frame_number);
001070  001271  // Usage : arg1 := media_VideoFrame();
001071  001272  // Notes : After a pointer to a valid video has been set with media_SetSector,
001072  001273  //       : calling this function shows each fram sequentially, returning
001073  001274  //       : the number of frames remaining. The position of the image is
001074  001275  //     : at the current origin as set with gfx_MoveTo(...);
001075  001276        
001076  001277  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001077  001278  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001078  001279  // Usage : media_SetAdd(arg1, arg2);
001079  001280  // Notes : Set uSD internal Address pointer for bytewise access
001080  001281        
001081  001282  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001082  001283  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001083  001284  // Usage : media_SetSector(arg1, arg2);
001084  001285  // Notes : Set uSD internal Sector pointer for sector block access
001085  001286        
001086  001287  func media_RdSector("*destination"), 1;
001087  001288  // Syntax: media_RdSector(*destination);
001088  001289  // Usage : media_RdSector(rdblock);
001089  001290  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001090  001291  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001091  001292  //       : After the read the Sector pointer is automatically incremented by 1.
001092  001293  //       : Returns TRUE if uSD response was TRUE
001093  001294        
001094  001295  func media_WrSector("*source"), 1;
001095  001296  // Syntax: media_WrSector(*source);
001096  001297  // Usage : media_WrSector(wrblock);
001097  001298  // Notes : Writes 512 bytes (256 words) from a source memory block
001098  001299  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001099  001300  //       : pointer is automatically incremented by 1.
001100  001301  //       : Returns TRUE if uSD response was TRUE
001101  001302        
001102  001303  func media_ReadByte(), 1;                // read a byte at the current stream position
001103  001304  // Syntax: media_RdByte();
001104  001305  // Usage : var := media_RdByte();
001105  001306  // Notes : Reads and Returns a single byte of data from the
001106  001307  //       : uSD card pointed to by the internal Address pointer.
001107  001308  //       : After the read the Address pointer is automatically
001108  001309  //       : incremented by 1.
001109  001310        
001110  001311  func media_ReadWord(), 1;                // read a word at the current stream position
001111  001312  // Syntax: media_ReadWord();
001112  001313  // Usage : var := media_ReadWord();
001113  001314  // *Notes : Reads and Returns a single word of data from the
001114  001315  //       : uSD card pointed to by the internal Address pointer.
001115  001316  //       : After the read the Address pointer is automatically
001116  001317  //       : incremented by 2.
001117  001318        
001118  001319  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001119  001320  // Syntax: media_WriteByte(arg1);
001120  001321  // Usage : var := media_WriteByte(arg1);
001121  001322  // *Notes : Writes and Returns xxxxx
001122  001323  //       : After the write the Address pointer is automatically
001123  001324  //       : incremented by 1.
001124  001325        
001125  001326  func media_WriteWord("word"), 1;            // write a word to the current stream position
001126  001327  // Syntax: media_WriteWord(arg1);
001127  001328  // Usage : var := media_WriteWord(arg1);
001128  001329  // *Notes : Writes and Returns xxxxx
001129  001330  //       : After the write the Address pointer is automatically
001130  001331  //       : incremented by 2.
001131  001332        
001132  001333  func media_Image("x", "y"), 0;            // display image at position x y
001133  001334  // Syntax: media_Image(x, y);
001134  001335  // Usage : media_Image(arg1, arg2);
001135  001336  // Notes : Display an image from the uSD card at screen location
001136  001337  //       : specified by x,y (top left corner). The location of the
001137  001338  //       : Image in the uSD card must be specified by
001138  001339  //       : media_setSector(Image_Sector_Add) function.
001139  001340        
001140  001341  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001141  001342  // Syntax: media_Flush();
001142  001343  // Usage : var := media_Flush();
001143  001344  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001144  001345  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001145  001346        
001146  001347  func media_Init(), 1;                    // initialize uSD card
001147  001348  // Usage : media_Init();
001148  001349  // Notes : Initialise uSD CARD
001149  001350  //       : Response: 0 = No Card
001150  001351  //       :           1 = Card Initialised
001151  001352        
001152  001353        
001153  001354  //==============================================//
001154  001355  // Communications Function Prototypes           //
001155  001356  //==============================================//
001156  001357  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001157  001358  // Syntax: com_Init(buffer, bufsize, qualifier);
001158  001359  // Usage1: com_Init(mybuf, 20, 0);
001159  001360  // Usage2: com_Init(mybuf, 20, ':');
001160  001361  // Notes : initialize a serial capture buffer for the comms input
001161  001362  //       : The program must declare a var array as a circular buffer.
001162  001363  //       : Usage1 declares a circular buffer which will continually
001163  001364  //       : buffer characters.
001164  001365  //       : Usage2 must receive ':' before any characters will
001165  001366  //       : accumulate in the buffer.
001166  001367        
001167  001368  func com_Reset(), 0;                 // reset the comms receiver
001168  001369  // Syntax: com_Reset();
001169  001370  // Usage : com_Reset();
001170  001371  // Notes : reset comms to default polled mode
001171  001372        
001172  001373  func com_Count(), 1;                // return count of characters in receive buffer
001173  001374  // Syntax: com_Count();
001174  001375  // Usage : arg := com_Count();
001175  001376  // Notes : return count of buffered characters in buffer attachment
001176  001377        
001177  001378  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001178  001379  // Syntax: com_Full();
001179  001380  // Usage : if (com_Full() ,,,, go read buffer;
001180  001381  // Notes : return true if buffer full (not necessarily an error if
001181  001382  //       : buffer is sized to a packet size)
001182  001383        
001183  001384  func com_Error(), 1;                // return comms errors comms error occurred
001184  001385  // Syntax: com_Error();
001185  001386  // Usage : if (com_Error() ) ...... take recovery action;
001186  001387  // Notes : return non zero if any errors low level comms errors occured
001187  001388  // returns :
001188  001389  // bit0 = Receiver Overflow Error
001189  001390  // bit1 = Receiver Framing Error
001190  001391  // bit2 = Transmit Buffer Overflow
001191  001392        
001192  001393  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001193  001394  // Syntax: com_Sync();
001194  001395  // Usage : com_Sync();
001195  001396  // return true if sync character has been received in com_Init("...") mode
001196  001397        
001197  001398        
001198  001399  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001199  001400  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001200  001401  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001201  001402  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001202  001403  // Notes : initialize a serial buffer for the COM0 output.
001203  001404  //       : The program must declare a var array as a circular buffer.
001204  001405  //       : When a TX buffer is declared for comms, the transmission
001205  001406  //       : of characters becomes non blocking. The only time
001206  001407  //       : blocking will occur is if the buffer has insufficient space
001207  001408  //       : to accept the next character, in which case the function
001208  001409  //       : will wait for buffer space to become available. If the
001209  001410  //       : TX buffer is no longer required, just set the buffer pointer
001210  001411  //       : to zero, the size in this case doesnt matter and is ignored.
001211  001412  //       : The function can resize or reallocated to another buffer at
001212  001413  //       : any time. The buffer is flushed before any changes are made.
001213  001414  //       : "pin" designates an IO pin to control a bi-directional 
001214  001415  //       : control device for half duplex mode. "pin" will go HI at the
001215  001416  //       : start of a transmission, and will return low after the final
001216  001417  //       : byte is transmitted. If not required, just set "pin" to zero.
001217  001418        
001218  001419        
001219  001420  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001220  001421  // Syntax: com_TXcount();
001221  001422  // Usage : arg := com_Count();
001222  001423  // Notes : return count of characters remaining in COM0 transmit buffer
001223  001424  //       : that was previously allocated with com_TXbuffer(...);
001224  001425        
001225  001426        
001226  001427  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001227  001428  // Syntax: com_TXemptyEvent(function);
001228  001429  // Usage : arg := com_TXemptyEvent();
001229  001430  // Notes : If a comms TX buffer that was previously allocated with
001230  001431  //       : com_TXbuffer(...);, this function can be used to set up
001231  001432  //       : a function to be called when the COM0 TX buffer is empty.
001232  001433  //       : This is useful for either reloading the TX buffer, setting
001233  001434  //       : or clearing a pin to change the direction of eg a RS485
001234  001435  //       : line driver, or any other form of traffic control.
001235  001436  //       : The event function must not have any parameters.
001236  001437  //       : To disable the event, simply call com_TXemptyEvent(0).
001237  001438  //       : com_TXbuffer(...); also resets any active event.
001238  001439  //       : com_TXemptyEvent returns any previous event function
001239  001440  //       : address, or zero if there was no previous function.
001240  001441        
001241  001442        
001242  001443  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001243  001444  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001244  001445  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001245  001446  // Notes : Expecting that a comms TX buffer that was previously allocated with
001246  001447  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001247  001448  //       : the buffer being sent wile it is being loaded. Mormally, when
001248  001449  //       : using buffered comms, the transmit process will begin
001249  001450  //       : immediately. This is often undesirable for 2 reasons,
001250  001451  //       : 1] you may wish to build a packet then send it later
001251  001452  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001252  001453  //       : as the FIFO buffer is constantly trying to empty while
001253  001454  //       : you are busy tring to fill it.
001254  001455  // return -1 if function is called illegally when TX comms is not buffered.
001255  001456  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001256  001457  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001257  001458        
001258  001459        
001259  001460  //=============================================================//
001260  001461  // Auxilliary Communications Function Prototypes
001261  001462  //=============================================================//
001262  001463  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001263  001464  // Syntax: com_Init(buffer, bufsize, qualifier);
001264  001465  // Usage1: com_Init(mybuf, 20, 0);
001265  001466  // Usage2: com_Init(mybuf, 20, ':');
001266  001467  // Notes : initialize a serial capture buffer for the comms input
001267  001468  //       : The program must declare a var array as a circular buffer.
001268  001469  //       : Usage1 declares a circular buffer which will continually
001269  001470  //       : buffer characters.
001270  001471  //       : Usage2 must receive ':' before any characters will
001271  001472  //       : accumulate in the buffer.
001272  001473        
001273  001474  func com1_Reset(), 0;
001274  001475  // Syntax: com_Reset();
001275  001476  // Usage : com_Reset();
001276  001477  // Notes : reset comms receiver to default polled mode
001277  001478        
001278  001479  func com1_Count(), 1;
001279  001480  // Syntax: com_Count();
001280  001481  // Usage : arg := com_Count();
001281  001482  // Notes : return count of characters in receive buffer
001282  001483        
001283  001484  func com1_Full(), 1;
001284  001485  // Syntax: com_Full();
001285  001486  // Usage : if (com_Full() ,,,, go read buffer;
001286  001487  // Notes : return true if receive buffer full
001287  001488        
001288  001489  func com1_Error(), 1;
001289  001490  // Syntax: com_Error();
001290  001491  // Usage : if (com_Error() ) ...... take recovery action;
001291  001492  // Notes : return non zero if any level comms errors occured
001292  001493  // returns :
001293  001494  // bit0 = Receiver Overflow Error
001294  001495  // bit1 = Receiver Framing Error
001295  001496  // bit2 = Transmit Buffer Overflow
001296  001497        
001297  001498  func com1_Sync(), 1;
001298  001499  // Syntax: com_Sync();
001299  001500  // Usage : com_Sync();
001300  001501  // Notes : return true if sync character has been received in com_Init("...") mode
001301  001502        
001302  001503        
001303  001504  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001304  001505  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001305  001506  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001306  001507  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001307  001508  // Notes : initialize a serial buffer for the COM1 output.
001308  001509  //       : The program must declare a var array as a circular buffer.
001309  001510  //       : When a TX buffer is declared for comms, the transmission
001310  001511  //       : of characters becomes non blocking. The only time
001311  001512  //       : blocking will occur is if the buffer has insufficient space
001312  001513  //       : to accept the next character, in which case the function
001313  001514  //       : will wait for buffer space to become available. If the
001314  001515  //       : TX buffer is no longer required, just set the buffer pointer
001315  001516  //       : to zero, the size in this case doesnt matter and is ignored.
001316  001517  //       : The function can resize or reallocated to another buffer at
001317  001518  //       : any time. The buffer is flushed before any changes are made.
001318  001519  //       : "pin" designates an IO pin to control a bi-directional 
001319  001520  //       : control device for half duplex mode. "pin" will go HI at the
001320  001521  //       : start of a transmission, and will return low after the final
001321  001522  //       : byte is transmitted. If not required, just set "pin" to zero.
001322  001523        
001323  001524        
001324  001525  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001325  001526  // Syntax: com1_TXcount();
001326  001527  // Usage : arg := com1_Count();
001327  001528  // Notes : return count of characters remaining in COM1 transmit buffer
001328  001529  //       : that was previously allocated with com1_TXbuffer(...);
001329  001530        
001330  001531        
001331  001532  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001332  001533  // Syntax: com1_TXemptyEvent(function);
001333  001534  // Usage : arg := com1_TXemptyEvent();
001334  001535  // Notes : If a comms TX buffer that was previously allocated with
001335  001536  //       : com1_TXbuffer(...);, this function can be used to set up
001336  001537  //       : a function to be called when the COM1 TX buffer is empty.
001337  001538  //       : This is useful for either reloading the TX buffer, setting
001338  001539  //       : or clearing a pin to change the direction of eg a RS485
001339  001540  //       : line driver, or any other form of traffic control.
001340  001541  //       : The event function must not have any parameters.
001341  001542  //       : To disable the event, simply call com1_TXemptyEvent(0).
001342  001543  //       : com1_TXbuffer(...); also resets any active event.
001343  001544  //       : com1_TXemptyEvent returns any previous event function
001344  001545  //       : address, or zero if there was no previous function.
001345  001546        
001346  001547        
001347  001548  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001348  001549  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001349  001550  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001350  001551  // Notes : Expecting that a comms TX buffer that was previously allocated with
001351  001552  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001352  001553  //       : the buffer being sent wile it is being loaded. Mormally, when
001353  001554  //       : using buffered comms, the transmit process will begin
001354  001555  //       : immediately. This is often undesirable for 2 reasons,
001355  001556  //       : 1] you may wish to build a packet then send it later
001356  001557  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001357  001558  //       : as the FIFO buffer is constantly trying to empty while
001358  001559  //       : you are busy tring to fill it.
001359  001560  // return -1 if function is called illegally when TX comms is not buffered.
001360  001561  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001361  001562  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001362  001563        
001363  001564  func serin1(), 1;
001364  001565  // Syntax: serin1();
001365  001566  // Usage : char := serin1();
001366  001567  // Notes : return the next available character from COM1
001367  001568        
001368  001569  func serout1("char"), 0;
001369  001570  // Syntax: serout1("char");
001370  001571  // Usage : serout1(ch);
001371  001572  // Notes : send character to COM1
001372  001573        
001373  001574  func com_SetBaud("comport","baudrate/10"), 1;
001374  001575  // Syntax: com_SetBaud("comport","baudrate/10");
001375  001576  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001376  001577  // Notes : sets to any viable baud rate from 160 to 655350
001377  001578  // return true if baud rate was acceptable
001378  001579        
001379  001580        
001380  001581        
001381  001582  //==============================================//
001382  001583  // Display Access                               //
001383  001584  //==============================================//
001384  001585  func disp_Init(), 0;                            // initialize display with required tables
001385  001586  // Syntax: disp_Init();
001386  001587  // Usage : disp_Init();
001387  001588  // Notes : Initialises or reinitialises the display.
001388  001589  //       : Normally used after restoration of peripheral power
001389  001590  //       : and after DeepSleep.
001390  001591        
001391  001592  func disp_SetReg("register", "data"), 0;
001392  001593  // Syntax: display_SetReg(register, data);
001393  001594  // Usage : display_SetReg(arg1, arg2);
001394  001595  // Notes : Sets uLCD specific display driver registers. Refer
001395  001596  //       : to appropriate display driver data sheet.
001396  001597        
001397  001598  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001398  001599  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001399  001600  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001400  001601  // Notes : Prepares the GRAM area for user access.
001401  001602  //       : Data can now be written with disp_GRAM.
001402  001603  //       : GRAM will be set accordingly for the correct screen mode.
001403  001604  //       : the LO word of the 32 bit pixel count is returned. This is
001404  001605  //       : usually all that is needed unlse GRAM area exceeds 256^2
001405  001606  //       : A copy of the 32bit value can be found in
001406  001607  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001407  001608        
001408  001609  func disp_WrGRAM("colour"), 0;
001409  001610  // Syntax: display_WrGRAM(colour);
001410  001611  // Usage : display_WrGRAM(arg);
001411  001612  // Notes : Data can be written to the GRAM consecutively using
001412  001613  //       : this function once the GRAM access window has been setup.
001413  001614        
001414  001615  func disp_WriteControl("value"), 0;             // write a control byte to the display
001415  001616  func disp_WriteWord("value"), 0;                // write a word to the display
001416  001617        
001417  001618        
001418  001619  func disp_ReadWord(), 1;                        // read a word from the display
001419  001620  // Syntax: disp_ReadWord();
001420  001621  // Usage : x:=disp_ReadWord();
001421  001622  // Notes : Read a word from the controller
001422  001623  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001423  001624  //       : print(disp_ReadWord());        // print ID
001424  001625  //       : (Many displays are write only)
001425  001626        
001426  001627                                                  //
001427  001628  //==============================================//
001428  001629  // unadorned SPI functions                      //
001429  001630  //==============================================//
001430  001631  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001431  001632  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001432  001633  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001433  001634  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001434  001635                                                  //
001435  001636  //==============================================//
001436  001637  // flash device specific functions              //
001437  001638  //==============================================//
001438  001639  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001439  001640  func flash_ID(), 1;                             // read ID code from FLASH device
001440  001641  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001441  001642  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001442  001643                                                  //
001443  001644                                                  //
001444  001645  //==============================================//
001445  001646  // string and character size function           //
001446  001647  //==============================================//
001447  001648  func charwidth("char"), 1;                      // return width of a character in pixel units
001448  001649  func charheight("char"), 1;                     // return height of a character in pixel units
001449  001650  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001450  001651  func strheight(), 1;                            // return height of a string in pixel units
001451  001652        
001452  001653        
001453  001654  //------------------------------------------------------------------//
001454  001655  //        I2C Function Prototypes
001455  001656  //------------------------------------------------------------------//
001456  001657  func I2C_Open("speed"), 0;
001457  001658  // Syntax: I2C_Open(speed),
001458  001659  // Usage : I2C_Open(I2C_MED);
001459  001660  // Notes : configures the I2C module
001460  001661  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001461  001662        
001462  001663  func I2C_Close(), 0;
001463  001664  // Syntax: I2C_Close();
001464  001665  // Usage : I2C_Close();
001465  001666  // Notes : disables the I2C1 module.
001466  001667        
001467  001668  func I2C_Start(), 1;
001468  001669  // Syntax: I2C_Start();
001469  001670  // Usage : I2C_Start();
001470  001671  // Notes : generates a Start condition.
001471  001672  //       : returns true if successful (usually ignored)
001472  001673        
001473  001674  func I2C_Stop(), 1;
001474  001675  // Syntax: I2C_Stop();
001475  001676  // Usage : I2C_Stop();
001476  001677  // Notes : generates a Stop condition.
001477  001678  //       : returns true if successful (usually ignored)
001478  001679        
001479  001680  func I2C_Restart(), 1;
001480  001681  // Syntax: I2C_Restart();
001481  001682  // Usage : I2C_Restart();
001482  001683  // Notes : generates a Restart condition.
001483  001684  //       : returns true if successful (usually ignored)
001484  001685        
001485  001686  func I2C_Read(), 1;
001486  001687  // Syntax: I2C_Read();
001487  001688  // Usage : ch := I2C_Read();
001488  001689  // Notes : reads a single byte from the I2C Bus.
001489  001690        
001490  001691  func I2C_Write("byte"), 1;
001491  001692  // Syntax: I2C_Write(byte);
001492  001693  // Usage : r := I2C_Write(ch);
001493  001694  // Notes : is used to write a byte to the I2C bus.
001494  001695  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001495  001696        
001496  001697  func I2C_Ack(), 0;
001497  001698  // Syntax: I2C_Ack();
001498  001699  // Usage : I2C_Ack();
001499  001700  // Notes : generates the acknowledge condition.
001500  001701        
001501  001702  func I2C_Nack(), 0;
001502  001703  // Syntax: I2C_Nack();
001503  001704  // Usage : I2C_Nack();
001504  001705  // Notes : generates the negative acknowledge condition.
001505  001706        
001506  001707  func I2C_AckStatus(), 0;
001507  001708  // Syntax: I2C_AckStatus();
001508  001709  // Usage : r := I2C_AckStatus();
001509  001710  // Notes : returns the ACK status from the device.
001510  001711        
001511  001712  func I2C_AckPoll("control"), 1;
001512  001713  // Syntax: I2C_AckPoll();
001513  001714  // Usage : r := I2C_AckPoll(0xA0);
001514  001715  // Notes : waits for a device to return from ACK polling.
001515  001716        
001516  001717  func I2C_Idle(), 0;
001517  001718  // Syntax: I2C_Idle();
001518  001719  // Usage : I2C_Idle();
001519  001720  // Notes : waits until the I2C Bus is Inactive.
001520  001721        
001521  001722  func I2C_Gets("buffer", "size"), 1;
001522  001723  // Syntax: I2C_Gets("buffer", "size");
001523  001724  // Usage : r := I2C_Gets(mybuf, 16);
001524  001725  // Notes : only reads up to "size" characters into "buffer"
001525  001726  //       : Reads up to asciiz terminator including terminator
001526  001727        
001527  001728  func I2C_Getn("buffer", "size"), 1;
001528  001729  // Syntax: I2C_Gets("buffer", "size");
001529  001730  // Usage : r := I2C_Gets(mybuf, 16);
001530  001731  // Notes : reads "size" bytes into "buffer"
001531  001732  //       :
001532  001733        
001533  001734  func I2C_Puts("buffer"), 1;
001534  001735  // Syntax: I2C_Puts("buffer");
001535  001736  // Usage : r := I2C_Puts(mybuf);
001536  001737  // Notes : writes an asciiz string to the I2C device
001537  001738  //       : returns count of characters written
001538  001739        
001539  001740  func I2C_Putn("buffer", "count"), 1;
001540  001741  // Syntax: I2C_Putn("buffer","count");
001541  001742  // Usage : r := I2C_Puts(mybuf,10);
001542  001743  // Notes : writes up to "size" bytes to the I2C device
001543  001744  //       : returns number of bytes written
001544  001745        
001545  001746        
001546  001747  //------------------------------------------------------------------//
001547  001748  //        Image Control Function Prototypes
001548  001749  //------------------------------------------------------------------//
001549  001750  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001550  001751  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001551  001752  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001552  001753  // Notes : set the position where the image will be displayed
001553  001754  //       : returns true if index was ok and function was successful.
001554  001755  //       : you may turn off an image so when img_Refresh is called,
001555  001756  //       : the image will not be shown
001556  001757        
001557  001758  func img_Enable("handle", "index"), 1;
001558  001759  // Syntax: img_Enable(handle, index);
001559  001760  // Usage : r := img_Enable(hImageList, imagenum);
001560  001761  // Notes : enable image in a image list
001561  001762  //       : returns true if index was ok and function was successful.
001562  001763  //       : this is the default state so when img_Refresh is called,
001563  001764  //       : all the images in the list will be shown
001564  001765  //       : if index is set to -1, all of the images are enabled
001565  001766        
001566  001767  func img_Disable("handle", "index"), 1;
001567  001768  // Syntax: img_Disable(handle, index);
001568  001769  // Usage : r := img_Disable(hImageList, imagenum);
001569  001770  // Notes : disable image in a image list
001570  001771  //       : returns true if index was ok and function was successful.
001571  001772  //       : you must turn off an image so when img_Refresh is called,
001572  001773  //       : the image will not be shown.
001573  001774  //       : if index is set to -1, all of the images are disabled
001574  001775        
001575  001776        
001576  001777  func img_Darken("handle", "index"), 1;
001577  001778  // Syntax: img_Darken(handle, index);
001578  001779  // Usage : r := img_Darken(hImageList, imagenum);
001579  001780  // Notes : darken image in a image list
001580  001781  //       : returns true if index was ok and function was successful.
001581  001782  //       : if index is set to -1, all of the images are darkened
001582  001783  //       : NB:- this feature will only work for the next refresh, then
001583  001784  //       : the image reverts back to normal when displayed again.
001584  001785        
001585  001786        
001586  001787  func img_Lighten("handle", "index"), 1;
001587  001788  // Syntax: img_Lighten(handle, index);
001588  001789  // Usage : r := img_Lighten(hImageList, imagenum);
001589  001790  // Notes : lighten image in a image list
001590  001791  //       : returns true if index was ok and function was successful.
001591  001792  //       : if index is set to -1, all of the images are lightened
001592  001793  //       : NB:- this feature will only work for the next refresh, then
001593  001794  //       : the image reverts back to normal when displayed again.
001594  001795        
001595  001796  func img_SetWord("handle", "index", "offset", "word"), 1;
001596  001797  // Syntax: img_SetWord(handle, index, offset, word);
001597  001798  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001598  001799  // Notes : set specified word (0-7) in a image entry
001599  001800  //       : returns TRUE if successful, return value usually ignored.
001600  001801        
001601  001802  func img_GetWord("handle", "index", "offset"), 1;
001602  001803  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001603  001804  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001604  001805  // Notes : returns specified word (0-14) from an image entry
001605  001806  //       : refer to image control entry offsets.
001606  001807        
001607  001808  func img_Show("handle", "index"), 1;
001608  001809  // Syntax: img_Show(handle, index);
001609  001810  // Usage : display image entry (regardless of enable/disable)
001610  001811  //       : returns TRUE if successful, return value usually ignored.
001611  001812        
001612  001813  func img_SetAttributes("handle", "index","value"), 1;
001613  001814  // Syntax: img_SetAttributes("handle", "index","offset");
001614  001815  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001615  001816  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001616  001817  //       : of an image control entry. "value" refers to various bits in
001617  001818  //       : the image control entry (see image attribute flags).
001618  001819  //       : A '1' bit in the "value" field SETS the respective bit
001619  001820  //       : in the IMAGE_FLAGS field of the image control entry.
001620  001821  //       : returns TRUE if successful, return value usually ignored.
001621  001822        
001622  001823  func img_ClearAttributes("handle", "index","value"), 1;
001623  001824  // Syntax: img_ClearAttributes("handle", "index","offset");
001624  001825  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001625  001826  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001626  001827  //       : of an image control entry. "value" refers to various bits in
001627  001828  //       : the image control entry (see image attribute flags)
001628  001829  //       : a '1' bit in the "value" field CLEARS the respective bit
001629  001830  //       : in the IMAGE_FLAGS field of the image control entry.
001630  001831  //       : returns TRUE if successful, return value usually ignored.
001631  001832        
001632  001833  func img_Touched("handle", "index"), 1;
001633  001834  // Syntax: r := img_Touched(handle, index);
001634  001835  // Usage : img_Touched(hndl, 17);
001635  001836  //       : returns -1 if image not touched, or returns index
001636  001837  // Notes : if index is passed as -1, function tests all images,
001637  001838  //       : and returns -1 if image not touched, or returns index.
001638  001839        
001639  001840        
001640  001841        
001641  001842        
001642  001843  //------------------------------------------------------------------//
001643  001844  //        Timer Function Prototypes
001644  001845  //------------------------------------------------------------------//
001645  001846  func sys_T(), 1;
001646  001847  // Syntax: sys_T();
001647  001848  // Usage : t := sys_T();
001648  001849  // Notes : return the current value of the rolling system timer (1msec) LO word
001649  001850        
001650  001851  func sys_T_HI(), 1;
001651  001852  // Syntax: sys_T_HI();
001652  001853  // Usage : t := sys_T_HI();
001653  001854  // Notes : return the current value of the rolling system timer (1msec) HI word
001654  001855        
001655  001856  func sys_SetTimer("timernum","value"), 0;
001656  001857  // Syntax: sys_SetTimer("timernum", "value");
001657  001858  // Usage : sys_SetTimer(TIMER5, 10000);
001658  001859  // Notes : set a countdown on the selected timer, or 'top up' if required.
001659  001860  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001660  001861  //       : Maximum timeout period is 65.535 seconds
001661  001862  //       : A timer can be read with the sys_GetTimer("timernum") function
001662  001863        
001663  001864  func sys_GetTimer("timernum"), 1;
001664  001865  // Syntax: t := sys_GetTimer("timernum");
001665  001866  // Usage : t := sys_GetTimer(TIMER3);
001666  001867  // Notes : returns 0 if timer has expired, or the current countdown value.
001667  001868  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001668  001869  //       : Maximum timeout period is 65.535 seconds
001669  001870  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001670  001871        
001671  001872  func sys_SetTimerEvent("timernum","function"), 1;
001672  001873  // Syntax: sys_SetTimerFunction("timernum", "function");
001673  001874  // Usage : sys_SetTimer(TIMER5, myfunc);
001674  001875  // Notes : set a function to be called for selected timer.
001675  001876  //       : When the timer reaches zero, the function is called.
001676  001877  //       : The called function must not have any parameters
001677  001878  //       : sys_SetTimerEvent returns any previous event function
001678  001879  //       : address, or zero if there was no previous function.
001679  001880        
001680  001881  func sys_EventQueue(), 1;
001681  001882  // Syntax: sys_EventQueue();
001682  001883  // Usage : tasks := sys_EventQueue();
001683  001884  // Notes : returns the max number of events that were pending
001684  001885  //       : in the timer queue since the last call to this function.
001685  001886  //       : This can be used to assess timer event overhead burden,
001686  001887  //       : especially after or during a sys_EventsPostpone action.
001687  001888        
001688  001889  func sys_EventsPostpone(), 0;
001689  001890  // Syntax: sys_EventPostpone();
001690  001891  // Usage : sys_EventPostpone();   // postpone the event queue
001691  001892  // Notes : postpone any events until the sys_EventResume function is executed
001692  001893  //       : The timer event queue will continue to queue events, but no action
001693  001894  //       : will take place untill a sys_EventResume function is encountered.
001694  001895  //       : The queue will continue to receive up to 32 events before discarding
001695  001896  //       : any further events. This function is required to allow a sequence of
001696  001897  //       : instructions or functions to occur that would otherwise be corrupted
001697  001898  //       : by an event occuring during the sequence of instructions or functions.
001698  001899  //       : A good example of this is when you set a position to print, if there
001699  001900  //       : was no way of locking the current sequence, an event may occur which
001700  001901  //       : does a similar thing, and a contention would occur - printing to
001701  001902  //       : the wrong position. This function should be used wisely, if any action
001702  001903  //       : that is required would take considerable time, it is better to disable
001703  001904  //       : any conflicting event functions with a bypass flag, then restart the
001704  001905  //       : conflicting event by re-issuing a timer value.
001705  001906        
001706  001907  func sys_EventsResume(), 0;
001707  001908  // Syntax: sys_EventsResume();
001708  001909  // Usage : sys_EventsResume();   // resume the event queue
001709  001910  // Notes : resume any postponed events. The queue will try to execute any timer
001710  001911  //       : events that were incurred during the postponed period.
001711  001912        
001712  001913        
001713  001914  func sys_Sleep("units"), 1;
001714  001915  // Syntax: t := sys_Sleep("units");
001715  001916  // Usage : t := sys_Sleep(10);
001716  001917  // Notes : sets the display into low power mode for a period of time.
001717  001918  //       : Touching the touch screen will also wake from sleep.
001718  001919  //       : Returns remaining sleep units.
001719  001920        
001720  001921  func iterator("offset"), 0;
001721  001922  // Syntax: t :=  iterator("offset");
001722  001923  // Usage : t :=  iterator(10);
001723  001924  // Notes : set the iterator size for ++/--
001724  001925  //       : The next postinc,postdec,preinc of predec will alter
001725  001926  //       : by the specified value.
001726  001927  //       : The offset will return to 1 after the next operation.
001727  001928        
001728  001929        
001729  001930        
001730  001931        
001731  001932  //------------------------------------------------------------------//
001732  001933  //         Touch Screen Function Prototypes
001733  001934  //------------------------------------------------------------------//
001734  001935        
001735  001936  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001736  001937  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001737  001938  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001738  001939  // Notes : Specifies a new touch detect region on the screen
001739  001940  //       : such that only touch activity in that region will
001740  001941  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001741  001942        
001742  001943  func touch_Set("mode"), 0;
001743  001944  // Syntax: touch_Set(mode);
001744  001945  // Usage : touch_Set(arg);
001745  001946  // Notes : Sets various Touch Screen related parameters
001746  001947  //       :
001747  001948  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001748  001949  //       : touch_Set(TOUCH_ENABLE);
001749  001950  //       : Enables and initialises Touch Screen hardware
001750  001951  //       :
001751  001952  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001752  001953  //       : touch_Set(TOUCH_DISABLE );
001753  001954  //       : Disables the Touch Screen
001754  001955  //       : Note: Touch Screen runs in the background and disabling
001755  001956  //       : it when not in use will free up extra resources
001756  001957  //       : such as 4DVM CPU cycles.
001757  001958  //       :
001758  001959  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001759  001960  //       : touch_Set(TOUCH_REGIONDEFAULT);
001760  001961  //       : This will reset the current active region to default
001761  001962  //       : to the full screen without the application having to
001762  001963  //       : set a new active region for the full screen.
001763  001964  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001764  001965  //       : that requre to be interfaced with an external pointing
001765  001966  //       : device, values that are poked into TOUCH_DRIVE will be
001766  001967  //       : read with the touch_Get() function)
001767  001968        
001768  001969        
001769  001970  func touch_Get("mode"), 1;
001770  001971  // Syntax: touch_Get(mode);
001771  001972  // Usage : arg1 := touch_Get(arg);
001772  001973  // Notes : Returns various Touch Screen parameters to caller
001773  001974  //       :
001774  001975  //       : mode = TOUCH_STATUS  (mode 0)
001775  001976  //       : var := touch_Get(TOUCH_STATUS);
001776  001977  //       : Returns the various states of the touch screen
001777  001978  //       : 0 = NOTOUCH
001778  001979  //       : 1 = TOUCH_PRESSED
001779  001980  //       : 2 = TOUCH_RELEASED
001780  001981  //       : 3 = TOUCH_MOVING
001781  001982  //       :
001782  001983  //       : mode = TOUCH_GETX   (mode 1)
001783  001984  //       : var := touch_Get(TOUCH_GETX);
001784  001985  //       : Returns the X coordinates of the touch
001785  001986  //       :
001786  001987  //       : mode = TOUCH_GETY   (mode 2)
001787  001988  //       : var := touch_Get(TOUCH_GETY);
001788  001989  //       : Returns the Y coordinates of the touch
001789  001990        
001790  001991  //------------------------------------------------------------------//
001791  001992  //        CTYPE Function Prototypes
001792  001993  //------------------------------------------------------------------//
001793  001994        
001794  001995  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001795  001996  // Syntax: isdigit("char");
001796  001997  // Usage : Var := isdigit(ch);
001797  001998  // Notes : char specifies the ascii character for the test
001798  001999  //     : 0 : char is not an ascii digit.
001799  002000  //     : 1 : char is an ascii digit..
001800  002001  //     : Valid range is "0123456789"
001801  002002        
001802  002003  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001803  002004  // Syntax: isxdigit("char");
001804  002005  // Usage : Var := isxdigit(ch);
001805  002006  // Notes : char specifies the ascii character for the test
001806  002007  //     : 0 : char is not an ascii hexadecimal digit.
001807  002008  //     : 1 : char is an ascii hexadecimal digit..
001808  002009  //     : Valid range is "0123456789ABCDEF"
001809  002010        
001810  002011  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001811  002012  // Syntax: isupper("char");
001812  002013  // Usage : Var := isupper(ch);
001813  002014  // Notes : char specifies the ascii character for the test
001814  002015  //     : 0 : char is not an ascii upper-case letter.
001815  002016  //     : 1 : char is an ascii upper-case letter.
001816  002017  //     : Valid range is "ABCD....WXYZ"
001817  002018        
001818  002019  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001819  002020  // Syntax: islower("char");
001820  002021  // Usage : Var := islower(ch);
001821  002022  // Notes : char specifies the ascii character for the test
001822  002023  //     : 0 : char is not an ascii lower-case letter.
001823  002024  //     : 1 : char is an ascii lower-case letter.
001824  002025  //     : Valid range is "abcd....wxyz"
001825  002026        
001826  002027  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001827  002028  // Syntax: isalpha("char");
001828  002029  // Usage : Var := isalpha(ch);
001829  002030  // Notes : char specifies the ascii character for the test
001830  002031  //     : 0 : char is not an ascii lower or upper case letter.
001831  002032  //     : 1 : char is an ascii lower or upper case letter.
001832  002033  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001833  002034        
001834  002035  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001835  002036  // Syntax: isalnum("char");
001836  002037  // Usage : Var := isalnum(ch);
001837  002038  // Notes : char specifies the ascii character for the test
001838  002039  //     : 0 : char is not an ascii alphanumeric character.
001839  002040  //     : 1 : char is an ascii alphanumeric character.
001840  002041  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001841  002042        
001842  002043  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001843  002044  // Syntax: isprint("char");
001844  002045  // Usage : Var := isprint(ch);
001845  002046  // Notes : char specifies the ascii character for the test
001846  002047  //     : 0 : char is not a printable ascii character.
001847  002048  //     : 1 : char is a printable ascii character.
001848  002049  //     : Valid range is "0x20...0x7F"
001849  002050        
001850  002051  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001851  002052  // Syntax: isspace("char");
001852  002053  // Usage : Var := isspace(ch);
001853  002054  // Notes : char specifies the ascii character for the test
001854  002055  //     : 0 : char is not a space type character.
001855  002056  //     : 1 : char is a space type character.
001856  002057  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001857  002058        
001858  002059  //unformatted
001859  002060  func iswhite("char"), 1;    //
001860  002061  // Syntax: iswhite("char");
001861  002062  // Usage : Var := iswhite(ch);
001862  002063  // Notes : char specifies the ascii character for the test
001863  002064  //     : 0 : char is not a space or tab character.
001864  002065  //     : 1 : char is not a space or tab character.
001865  002066  //     : Valid range is space or tab
001866  002067        
001867  002068  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001868  002069  // Syntax: toupper("char");
001869  002070  // Usage : Var := toupper(ch);
001870  002071  // Notes : char specifies the ascii character for the test
001871  002072  //     : "ABCD....XYZ" : if character is a lower case letter.
001872  002073  //     : char : if character is not a lower case letter.
001873  002074  //     : Valid range is "abcd....wxyz"
001874  002075        
001875  002076  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001876  002077  // Syntax: tolower("char");
001877  002078  // Usage : Var := tolower(ch);
001878  002079  // Notes : char specifies the ascii character for the test
001879  002080  //     : "abcd....xyz" : if character is an upper case letter.
001880  002081  //     : char : if character is not an upper case letter.
001881  002082  //     : Valid range is "ABCD....WXYZ"
001882  002083        
001883  002084  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001884  002085  // Syntax: LObyte(var);
001885  002086  // Usage : myVar := LObyte(myvar2);
001886  002087  // Notes : var specifies the user variable
001887  002088  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001888  002089        
001889  002090  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001890  002091  // Syntax: HIbyte(var);
001891  002092  // Usage : myVar := HIbyte(myvar2);
001892  002093  // Notes : var specifies the user variable
001893  002094  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001894  002095        
001895  002096        
001896  002097  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001897  002098  // Syntax: ByteSwap(var);
001898  002099  // Usage : myVar := ByteSwap(myvar2);
001899  002100  // Notes : var specifies the user variable
001900  002101  //     : Returns the endian swapped value of a 16 bit variable
001901  002102        
001902  002103        
001903  002104  //------------------------------------------------------------------//
001904  002105  //        Memory Allocation Function Prototypes
001905  002106  //------------------------------------------------------------------//
001906  002107        
001907  002108  func mem_Alloc("size"), 1;
001908  002109  // Syntax: mem_Alloc(bytesize);
001909  002110  // Usage : myvar := mem_Alloc(100);
001910  002111  // Notes : Allocate a block of memory to pointer myvar
001911  002112  //       : The allocated memory contains garbage but is a fast allocation.
001912  002113  //       : The block must later be released with mem_Free();
001913  002114  //       : returns 0 if function fails
001914  002115        
001915  002116  func mem_AllocV("size"), 1;
001916  002117  // Syntax: mem_AllocV(bytesize);
001917  002118  // Usage : myvar := mem_AllocV(100);
001918  002119  // Notes : Allocate a block of memory to pointer myvar
001919  002120  //       : The block of memory is filled with signature values
001920  002121  //       : the block starts with A5,5A then fills with incrementing
001921  002122  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001922  002123  //       : This can be helpful when debugging
001923  002124  //       : The block must later be released with mem_Free();
001924  002125  //       : returns 0 if function fails
001925  002126        
001926  002127  func mem_AllocZ("size"), 1;
001927  002128  // Syntax: mem_AllocZ(bytesize);
001928  002129  // Usage : myvar := mem_AllocC(100);
001929  002130  // Notes : Allocate a zeroed block of memory to pointer myvar
001930  002131  //       : The block of memory is filled with zeroes
001931  002132  //       : The block must later be released with mem_Free();
001932  002133  //       : returns 0 if function fails
001933  002134        
001934  002135  func mem_Realloc("ptr", "size"), 1;
001935  002136  // Syntax: myvar := mem_Realloc("ptr", "size");
001936  002137  // Usage : myvar := mem_Realloc(ptr, size);
001937  002138  // Notes : The function may move the memory block to a new location,
001938  002139  //       : in which case the new location is returned.
001939  002140  //       : The content of the memory block is preserved up to the lesser
001940  002141  //       : of the new and old sizes, even if the block is moved.
001941  002142  //       : If the new size is larger, the value of the newly allocated
001942  002143  //       : portion is indeterminate. In case that ptr is NULL,
001943  002144  //       : the function behaves exactly as mem_Alloc, assigning a new block
001944  002145  //       : of size bytes and returning a pointer to the beginning of it.
001945  002146  //       : In case that the size is 0, the memory previously allocated in
001946  002147  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001947  002148  //       : pointer is returned.
001948  002149        
001949  002150  func mem_Free("allocation"), 1;
001950  002151  // Syntax: myvar := mem_Free(allocation);
001951  002152  // Usage : myvar := mem_Free(myvar);
001952  002153  // Notes : De-allocate a block of memory previously created with
001953  002154  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001954  002155  //       : returns 0 if function fails
001955  002156        
001956  002157  func mem_Heap(), 1;
001957  002158  // Syntax: myvar := mem_Heap();
001958  002159  // Usage : myvar := mem_Heap();
001959  002160  // Notes : returns bytecount available in heap
001960  002161  //       :
001961  002162        
001962  002163  func mem_Set("ptr","char","size"), 1;
001963  002164  // Syntax: mem_Set(ptr,char,bytesize);
001964  002165  // Usage : mem_Set(p, 'A', 100);
001965  002166  // Notes : fill a block of memory with a byte value
001966  002167  //       : returns ptr
001967  002168        
001968  002169  func mem_Copy("src", "dest", "bytecount"), 1;
001969  002170  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001970  002171  // Usage : myvar := mem_Copy(p1, p2, 100);
001971  002172  // Notes : copy a word aligned block of memory from src to dest
001972  002173  //       : Note that count is a byte count, this facilitates
001973  002174  //       : copying word aligned byte arrays when using word
001974  002175  //       : aliggned packed strings.
001975  002176  //       : returns src
001976  002177        
001977  002178  func mem_Compare("ptr1","ptr2","count"), 1;
001978  002179  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001979  002180  // Usage : myvar := mem_Compare(p1, p2, 100);
001980  002181  // Notes : compare blocks of memory at src, dest
001981  002182  //       : returns 0 if we have a match
001982  002183        
001983  002184  //------------------------------------------------------------------//
001984  002185  //        FAT16 Function Prototypes
001985  002186  //------------------------------------------------------------------//
001986  002187        
001987  002188  func file_Error(), 1;
001988  002189  // Syntax: myvar := file_Error();
001989  002190  // Usage : e := file_Error();
001990  002191  // Notes : return the most recent file error.
001991  002192  //       :
001992  002193        
001993  002194  func file_Count("filename"), 1;
001994  002195  // Syntax: count := file_Count("filename");
001995  002196  // Usage : count := file_Count("*.4dg");
001996  002197  // Notes : returns number of files found that match the criteria
001997  002198        
001998  002199  func file_Dir("filename"), 1;
001999  002200  // Syntax: count := file_Dir("filename");
002000  002201  // Usage : count := file_Dir("*.4dg");
002001  002202  // Notes : streams a string of filenames that agree with the search key
002002  002203  //       : returns number of files found that match the criteria
002003  002204        
002004  002205  func file_FindFirst("fname"), 1;
002005  002206  // Syntax: res := file_FindFirst("fname");
002006  002207  // Usage : if (file_FindFirst("*.4xe") ....
002007  002208  // Notes : returns true if at least 1 file exists
002008  002209  //       : that satisfies the file argument.
002009  002210  //       : Wildcards are usually used so if
002010  002211  //       : file_FindFirst returns true, further
002011  002212  //       : tests can be made using file_FindNext();
002012  002213  //       : to find all the files that match the
002013  002214  //       : wildcard class. Note that the stream behaviour
002014  002215  //       : is the same as file_Dir.
002015  002216  //       :
002016  002217        
002017  002218  func file_FindNext(), 1;
002018  002219  // Syntax: res := file_FindNext();
002019  002220  // Usage : while ((file_FindNext()) ....
002020  002221  // Notes : returns true if more file exists
002021  002222  //       : that satisfies the file argument
002022  002223  //       : that was given for  file_FindFirst.
002023  002224  //       : Wildcards must be used for
002024  002225  //       : file_FindFirst, else this function will
002025  002226  //       : always return zero as the only occurence
002026  002227  //       : will have already been found.
002027  002228  //       : Note that the stream behaviour
002028  002229  //       : is the same as file_Dir.
002029  002230  //       :
002030  002231        
002031  002232  func file_Exists("fname"), 1;
002032  002233  // Syntax: res := file_Exists("fname"),
002033  002234  // Usage : if(file_Exists("myfile") ....
002034  002235  // Notes : returns true if file exists
002035  002236  //       :
002036  002237        
002037  002238  func file_Open("fname", "mode"), 1;
002038  002239  // Syntax: handle := file_Open("fname","mode"),
002039  002240  // Usage : handle := file_Open("myfile.txt", 'r');
002040  002241  // Notes : returns handle if file exists
002041  002242  //       :
002042  002243        
002043  002244  func file_Close("handle"), 1;
002044  002245  // Syntax: res := file_Close("handle");
002045  002246  // Usage : res := file_Close(hnd1);
002046  002247  // Notes : returns true if file closed ok
002047  002248  //       :
002048  002249        
002049  002250  func file_Read("*dest", "size", "handle"), 1;
002050  002251  // Syntax: res := file_Read("*dest", "size", "handle"),
002051  002252  // Usage : res := file_Read(memblock,20,hnd1);
002052  002253  // Notes : returns number of characters read
002053  002254  //       : if "dest" is zero, data is read direct to GRAM window
002054  002255  //       :
002055  002256        
002056  002257        
002057  002258  func file_Seek("handle", "HiWord", "LoWord"), 1;
002058  002259  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002059  002260  // Usage : res := file_Seek(hSource, 0, 0x1234);
002060  002261  // Notes : set file position to 0x00001234 (byte position 4660)
002061  002262  //       : for the file handle so subsequent data may be read
002062  002263  //       : from that position onwards with file_GetC(...),
002063  002264  //       : file_GetW(...) or file_GetS(...), or an image
002064  002265  //       : can be displayed with file_Image(...)
002065  002266  // Notes : returns true if ok, usually ignored
002066  002267        
002067  002268  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002068  002269  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002069  002270  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002070  002271  // Notes : set file seek position to 123000
002071  002272  //       : for the file handle so subsequent data may be read
002072  002273  //       : from that record position onwards with file_GetC(...),
002073  002274  //       : file_GetW(...) or file_GetS(...), or an image
002074  002275  //       : can be displayed with file_Image(...)
002075  002276  // Notes : returns true if ok, usually ignored
002076  002277        
002077  002278  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002078  002279  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002079  002280  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002080  002281  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002081  002282  //       : returns true if function succeeded
002082  002283        
002083  002284  func file_Write("*source", "size", "handle"), 1;
002084  002285  // Syntax: res := fwrite("*source", "size", "handle"),
002085  002286  // Usage : res := fwrite(memblock, 20, hnd1);
002086  002287  // Notes : returns number of bytes written
002087  002288  //       :
002088  002289        
002089  002290  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002090  002291  // Syntax: file_Size("handle", &HiWord, &LoWord);
002091  002292  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002092  002293  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002093  002294  //       : returns true if function succeeded
002094  002295        
002095  002296  func file_Image("x", "y", "handle"), 1;
002096  002297  // Syntax: file_Image(x, y, handle);
002097  002298  // Usage : file_Image(10, 10, hnd1);
002098  002299  // Notes : Display an image from a file at the current file position.
002099  002300  //       : The image is displayed at x,y (with respect to top left corner).
002100  002301  //       : If there is more than 1 image in the file, it can be
002101  002302  //       : accessed with file_Seek(...)
002102  002303        
002103  002304  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002104  002305  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002105  002306  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002106  002307  // Notes : Save a image from screen to file at the current file position.
002107  002308  //       : The image can later be displayed with file_Image(...);
002108  002309  //       : The file may be opened in append mode to accumulate multiple
002109  002310  //       : images. Later, the images can be accessed with file_Seek(...);
002110  002311  //       : Note that the image will be sector aligned.
002111  002312  //       : All image headers must start on a sector boundary.
002112  002313  //       : The image is saved from x, y (with respect to top left corner)
002113  002314  //       : and the capture area is determined by "width" and "height".
002114  002315  //       : returns 0 if function succeeded
002115  002316        
002116  002317  func file_PutC("char","handle"), 1;
002117  002318  // Syntax: file_PutC("char", "handle");
002118  002319  // Usage : file_PutC('x', hndl);
002119  002320  // Notes : returns true if function succeeded
002120  002321        
002121  002322  func file_GetC("handle"), 1;
002122  002323  // Syntax: file_GetC("handle");
002123  002324  // Usage : mychar := fgetC("handle");
002124  002325  // Notes : returns next char from file
002125  002326        
002126  002327  func file_PutW("word","handle"), 1;
002127  002328  // Syntax: file_PutW("word","handle");
002128  002329  // Usage : file_PutW(0x1234, hndl);
002129  002330  // Notes : returns true if function succeeded
002130  002331        
002131  002332  func file_GetW("handle"), 1;
002132  002333  // Syntax: file_GetW("handle");
002133  002334  // Usage : myword := fgetW("handle");
002134  002335  // Notes : returns next word in file
002135  002336        
002136  002337  func file_PutS("*source", "handle"), 1;
002137  002338  // Syntax: res := file_Puts("*source", "handle"),
002138  002339  // Usage : res := file_Puts(mystring, hnd1);
002139  002340  // Notes : returns number of characters written
002140  002341  //       :
002141  002342        
002142  002343  func file_GetS("*string", "size", "handle"), 1;
002143  002344  // Syntax: res := file_Gets("*string", "size", "handle");
002144  002345  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002145  002346  // Notes : get a string from a file
002146  002347  //       : returns pointer to string or null if failed.
002147  002348  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002148  002349  //       : NB:- only reads up to "size-1" characters into "string"
002149  002350  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002150  002351  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002151  002352  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002152  002353  //       : C] It reaches the end of file
002153  002354  //       : D] A read error occurs.
002154  002355        
002155  002356        
002156  002357  func file_Erase("fname"), 1;
002157  002358  // Syntax: res := file_Erase("fname");
002158  002359  // Usage : res := file_Erase("myfile.txt");
002159  002360  // Notes : returns true if successful
002160  002361  //       :
002161  002362        
002162  002363  func file_Rewind("handle"), 1;
002163  002364  // Syntax: res := file_Rewind("handle");
002164  002365  // Usage : res := file_Rewind(hnd1);
002165  002366  // Notes : returns true if file rewound ok (usually ignored)
002166  002367  //       : resets the file pointer the the beginning of the open file.
002167  002368        
002168  002369  func file_LoadFunction("fname.4xe"), 1;
002169  002370  // Syntax: res := file_LoadFunction("fname.4fn");
002170  002371  // Usage : myfunc := file_LoadFunction(myfuncname);
002171  002372  // Notes : Load a function or program from disk and
002172  002373  //       : return a function pointer to the allocation.
002173  002374  //       : The function can then be invoked just like any other
002174  002375  //       : function would be called via a function pointer.
002175  002376  //       : Parameters may be passed to it in a conventional way.
002176  002377  //       : The function may be discarded at any time when no
002177  002378  //       : longer required, thus freeing its memory resources.
002178  002379  //       : The loaded function can be discarded with mem_Free(..)
002179  002380  //       : eg:
002180  002381  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002181  002382  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002182  002383  //       : then elsewhere in your program:-
002183  002384  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002184  002385  //       : if(res == QUIT_APPLICATION) goto exitApp;
002185  002386  //       : Later in your program, when popupWindow is no longer
002186  002387  //       : required for the application:-
002187  002388  //       : res := mem_Free(popupWindow);
002188  002389  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002189  002390  //       : The callers stack is shared by the loaded function,
002190  002391  //       : however any global variables in the loaded function
002191  002392  //       : are private to that function.
002192  002393  //
002193  002394        
002194  002395  func file_Run("fname.4xe", "arglistptr"), 1;
002195  002396  // Syntax: res := file_Run("fname.4xe","arglistptr");
002196  002397  // Usage : res := file_Run(fname, argptr);
002197  002398  // Notes : current program releases any allocated memory but
002198  002399  //       : retains the stack and global memory.
002199  002400  //       : If arglistptr is 0, no arguments are passed, else
002200  002401  //       : arglist points to an array, the first element being
002201  002402  //       : the number of elements in the array.
002202  002403  //       : func 'main' in the called program accepts
002203  002404  //       : the arguments, if any. THe arguments can only
002204  002405  //       : be passed by value, no pointers or references can be
002205  002406  //       : used as all memory is cleared before the file
002206  002407  //       : is loaded. Refer to file_Exec and file_LoadFunction
002207  002408  //       : for functions that can pass by reference.
002208  002409        
002209  002410  func file_Exec("fname.4xe", "arglistptr"), 1;
002210  002411  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002211  002412  // Usage : res := file_Exec("fname.4xe","arglistptr");
002212  002413  // Notes : returns like a function, current program
002213  002414  //       : calling program is kept active and control returns to it.
002214  002415  //       : If arglistptr is 0, no arguments are passed, else
002215  002416  //       : arglist points to an array, the first element being
002216  002417  //       : the number of elements in the array.
002217  002418  //       : func 'main' in the called program accepts the arguments.
002218  002419  //       : This function is similar to file_LoadFunction(...), however,
002219  002420  //       : the function argument list is passed by pointer, and
002220  002421  //       : the memory consumed by the function is released as
002221  002422  //       : soon as the function completes.
002222  002423        
002223  002424  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002224  002425  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002225  002426  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002226  002427  // Notes : Reads a control file to create an image list.
002227  002428  //       : Returns NULL if function fails.
002228  002429  //       : Returns a handle (pointer to the memory allocation) to the
002229  002430  //       : image control list that has been created.
002230  002431  //       : "fname1" is the control list filename "*.dat"
002231  002432  //       : "fname2" is the image filename "*.gci"
002232  002433        
002233  002434  // Notes : This function Calculates the size of a chunk of memory required for
002234  002435  //       : a image list and populates it from the image control file ("*.dat")
002235  002436  //       : therefore, when imagelist is no longer required, you must de-allocate
002236  002437  //       : the image list memory by using eg:- mem_Free(hImagelist);
002237  002438  //       : to restore the heap.
002238  002439  //       :
002239  002440  //       : mode 0:- it is assumed that there is a graphics file with the
002240  002441  //       : file extension "fname2.gci". In this case, the images have been stored
002241  002442  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002242  002443  //       : "fname1.dat" file are saved in the image control so that the image control
002243  002444  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002244  002445  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002245  002446  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002246  002447  //       : for the file offsets and save them in the relevant entries in the image control.
002247  002448  //       : The penalty is that images take longer to find when displayed due to file_Seek
002248  002449  //       : overheads.
002249  002450  //
002250  002451  //       : mode 1:- it is assumed that there is a graphics file with the
002251  002452  //       : file extension "fname2.gci". In this case, the images have been stored
002252  002453  //       : in a FAT16 file concurrently, and the offset of the images are saved
002253  002454  //       : in the image control so that image file (*.gci) can be mapped to directly.
002254  002455  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002255  002456  //       : internally. This means that there is no seek time penalty, however, the
002256  002457  //       : image list takes a lot longer to build, as all the seeking is done at control
002257  002458  //       : build time.
002258  002459        
002259  002460  //       : mode 2:- the graphics file with the is placed in a partitioned area
002260  002461  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002261  002462  //       : disk, and the absolute address of the images are saved in the DAT file
002262  002463  //       : This is the fastest operation of the image control as there is no seeking
002263  002464  //       : or other disk activity taking place.
002264  002465        
002265  002466  func file_Mount(), 1;
002266  002467  // Syntax: r := file_Mount();
002267  002468  // Usage : r := file_Mount();
002268  002469  // Notes : Create a control block for FAT16 and mount the File System
002269  002470        
002270  002471  func file_Unmount(), 0;
002271  002472  // Syntax: file_Unmount();
002272  002473  // Usage : file_Unmount();
002273  002474  // Notes : release any control block and buffers for FAT16
002274  002475  //       : and unmount the File System
002275  002476        
002276  002477  func file_PlayWAV("fname1"), 1;
002277  002478  // Syntax: file_PlayWAV("fname1");
002278  002479  // Usage : file_PlayWAV("ding.wav");
002279  002480  // Notes : Play a wave file with filename "fname1"
002280  002481  //       : This function automatically grabs a chunk
002281  002482  //       : of memory for a file buffer, and a wave
002282  002483  //       : buffer. The minimum memory requirement is
002283  002484  //       : about 580 bytes for the disk io service and
002284  002485  //       : a minimum wave buffer size of 1024. The siz
002285  002486  //       : of the wave buffer allocation
002286  002487  //       : can be increased by the snd_BufSize function.
002287  002488  //       : The default size 1024 bytes.
002288  002489  //       : NB the memory is only required during the
002289  002490  //       : duration of play, and is automatically
002290  002491  //       : released while not in use.
002291  002492  //       : See the Sound Class services for other associated controls.
002292  002493  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002293  002494  //       : If errors occured, the folling is returned
002294  002495  //       : -7  : Insufficient memory available for WAV buffer and file
002295  002496  //       : -6  : cant play this rate
002296  002497  //       : -5  : no data chunk found in first rsector
002297  002498  //       : -4  : no format data
002298  002499  //       : -3  : no wave chunk signature
002299  002500  //       : -2  : bad wave file format
002300  002501  //       : -1  : file not found
002301  002502        
002302  002503        
002303  002504        
002304  002505  //------------------------------------------------------------------//
002305  002506  //        Sound Class Services
002306  002507  //------------------------------------------------------------------//
002307  002508        
002308  002509  func snd_Volume("var"), 0;
002309  002510  // Syntax: snd_Volume("var");
002310  002511  // Usage : snd_Volume(30);
002311  002512  // Notes : set sound playback volume.  Var must
002312  002513  //       : be in the range from 8 (min volume)
002313  002514  //       : to 127 (max volume). If var is less
002314  002515  //       : than 8 volume is set to 8, and if
002315  002516  //       : var > 127 it is set to 127.
002316  002517        
002317  002518  func snd_Pitch("pitch"), 1;
002318  002519  // func snd_Pitch("freq"), 1;
002319  002520  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002320  002521  // Notes : sets the samples playback rate to a different frequency
002321  002522  //       : The minimum value is 4khz
002322  002523  //       : Setting the pitch to zero restores the original sample rate
002323  002524  //       : Return value is the samples original sample rate.
002324  002525        
002325  002526  func snd_BufSize("var"), 0;
002326  002527  // Syntax: snd_BufSize("var");
002327  002528  // Usage : snd_BufSize(2);
002328  002529  // Notes : specify the a memory chunk size for the wavefile buffer.
002329  002530  //       : default size 1024 bytes.
002330  002531  //       : 0 = 1024 bytes (default)
002331  002532  //       : 1 = 2048 bytes
002332  002533  //       : 2 = 4096 bytes
002333  002534  //       : 3 = 8192 bytes
002334  002535        
002335  002536  func snd_Stop(), 0;
002336  002537  // Syntax: snd_Stop();
002337  002538  // Usage : snd_Stop();
002338  002539  // Notes : stop any sound that is playing, releasing
002339  002540  //       : buffers and closes any open wav file.
002340  002541        
002341  002542  func snd_Pause(), 0;
002342  002543  // Syntax: snd_Pause();
002343  002544  // Usage : snd_Pause();
002344  002545  // Notes : pauses any sound that is playing, does nothing
002345  002546  //       : until sound is resumed with snd_Continue().
002346  002547  //       : The sample cam be terminated with snd_Stop.
002347  002548  //       : buffers and closes any open wav file.
002348  002549        
002349  002550  func snd_Continue(), 0;
002350  002551  // Syntax: snd_Continue();
002351  002552  // Usage : snd_Continue();
002352  002553  // Notes : resume any sound that is paused by snd_Pause.
002353  002554        
002354  002555  func snd_Playing(), 1;
002355  002556  // Syntax: snd_Playing();
002356  002557  // Usage : r := snd_Playing();
002357  002558  // Notes : returns 0 if sound has finished playing,
002358  002559  //       : else return number of 512 byte blocks to go.
002359  002560        
002360  002561        
002361  002562        
002362  002563  //------------------------------------------------------------------//
002363  002564  //        String Class Services
002364  002565  //------------------------------------------------------------------//
002365  002566        
002366  002567  func str_Ptr("&var"), 1;
002367  002568  // Syntax: str_Ptr(&var);
002368  002569  // Usage : p := str_Ptr(&var);
002369  002570  // Notes : return a byte pointer to a word region
002370  002571        
002371  002572  func str_GetD("&ptr", "&var"), 1;
002372  002573  // Syntax: str_GetD(&ptr, &var);
002373  002574  // Usage : ok := str_GetD(&ptr, &var);
002374  002575  // Notes : convert number in a string to DWORD ( myvar[2] )
002375  002576  //       : returns true if function succeeds, advancing ptr
002376  002577        
002377  002578  func str_GetW("&ptr", "&var"), 1;
002378  002579  // Syntax: str_GetW(&ptr, &var);
002379  002580  // Usage : ok := str_GetW(&ptr, &var);
002380  002581  // Notes : convert number in a string to WORD ( myvar )
002381  002582  //       : returns true if function succeeds, advancing ptr
002382  002583        
002383  002584  func str_GetHexW("&ptr", "&var"), 1;
002384  002585  // Syntax: str_GetHexW(&ptr, &var);
002385  002586  // Usage : ok := str_GetHexW(&ptr, &var);
002386  002587  // Notes : convert HEX number in a string to WORD ( myvar )
002387  002588  //       : returns true if function succeeds, advancing ptr
002388  002589        
002389  002590  func str_GetC("&ptr", "&var"), 1;
002390  002591  // Syntax: str_GetC(&ptr, &var);
002391  002592  // Usage : ok := str_GetC(&ptr, &var);
002392  002593  // Notes : get a valid ascii char in a string to WORD ( myvar )
002393  002594  //       : returns true if function succeeds, advancing ptr
002394  002595        
002395  002596  func str_GetByte("ptr"), 1;
002396  002597  // Syntax: str_GetByte(ptr);
002397  002598  // Usage : myvar := str_GetByte(ptr);
002398  002599  // Notes : get a byte to myvar
002399  002600  //       : returns value
002400  002601        
002401  002602  func str_GetWord("ptr"), 1;
002402  002603  // Syntax: GetWord(ptr);
002403  002604  // Usage : GetWord(ptr);
002404  002605  // Notes : get a word to myvar
002405  002606  //       : returns value
002406  002607        
002407  002608  func str_PutByte("ptr","val"), 0;
002408  002609  // Syntax: str_PutByte(ptr);
002409  002610  // Usage : myvar := str_PutByte(ptr);
002410  002611  // Notes : put a byte at ptr
002411  002612  //       : returns value
002412  002613        
002413  002614  func str_PutWord("ptr","val"), 0;
002414  002615  // Syntax: str_PutWord("ptr","val");
002415  002616  // Usage : str_PutWord(p,100);
002416  002617  // Notes : put word 100 at current pointer location
002417  002618  //       : returns value
002418  002619        
002419  002620  func str_Match("&ptr", "*str"), 1;
002420  002621  // Syntax: str_Match(&ptr, *str);
002421  002622  // Usage : r := str_Match(&p, "hello");
002422  002623  // Notes : Case sensitive match
002423  002624  //       : returns true if function succeded, andvancing pointer to position past
002424  002625  //       : the matched item. Note that any whitespace characters are skipped
002425  002626  //       : in the source string prior to the test.
002426  002627        
002427  002628  func str_MatchI("&ptr", "*str"), 1;
002428  002629  // Syntax: str_MatchI(&ptr, *str);
002429  002630  // Usage : r := str_MatchI(&p, "hello");
002430  002631  // Notes : Case insensitive match
002431  002632  //       : returns true if function succeded, andvancing pointer to position past
002432  002633  //       : the matched item. Note that any whitespace characters are skipped
002433  002634  //       : in the source string prior to the test.
002434  002635        
002435  002636  func str_Find("&ptr", "*str"), 1;
002436  002637  // Syntax: str_Find(&ptr, *str);
002437  002638  // Usage : n := str_Find(&p, "hello");
002438  002639  // Notes : given the address of a pointer to a source string as the
002439  002640  //       : first argument, and a pointer to a test string as the second
002440  002641  //       : argument, attempt to find the position of the matching string
002441  002642  //       : in the source string. The test is performed with case sensitivity.
002442  002643  //       : return 0 if not found, else returns the address of the first
002443  002644  //       : character of the match. NB:- The source pointer is not altered.
002444  002645        
002445  002646  func str_FindI("&ptr", "*str"), 1;
002446  002647  // Syntax: str_Find(&ptr, *str);
002447  002648  // Usage : n := str_Find(&p, "hello");
002448  002649  // Notes : given the address of a pointer to a source string as the
002449  002650  //       : first argument, and a pointer to a test string as the second
002450  002651  //       : argument, attempt to find the position of the matching string
002451  002652  //       : in the source string. The test is performed with no case
002452  002653  //       : sensitivity, eg upper and lower case chars are accepted.
002453  002654  //       : return 0 if not found, else returns the address of the first
002454  002655  //       : character of the match. NB:- The source pointer is not altered.
002455  002656        
002456  002657  func str_Length("ptr"), 1;
002457  002658  // Syntax: str_Length(ptr);
002458  002659  // Usage : len := str_Ptr(mystring);
002459  002660  // Notes : return the length of a byte aligned string excluding terminator
002460  002661        
002461  002662  func str_Printf("&ptr", "*format"), 1;
002462  002663  // Syntax: str_Printf("&ptr", "*format");
002463  002664  // Usage : r := str_Printf(&p, "%8s");
002464  002665  // Notes : refer to documentation
002465  002666  //       :
002466  002667        
002467  002668  func str_Cat("dest","src"), 1;
002468  002669  // Syntax: str_Append("&dest","&src");
002469  002670  // Usage : str_Append(&buf,"Hello");
002470  002671  // Notes : Appends a copy of the source string to the destination string.
002471  002672  //       : The terminating null character in destination is overwritten by
002472  002673  //       : the first character of source, and a new null-character is appended
002473  002674  //       : at the end of the new string formed by the concatenation of both in destination.
002474  002675  //       : returns destination.
002475  002676        
002476  002677  func str_CatN("dest","src","count"), 1;
002477  002678  // Syntax: str_Append("&dest","&src","count");
002478  002679  // Usage : str_Append(&buf,"Monday",3);
002479  002680  // Notes : Appends a copy of the source string to the destination string.
002480  002681  //       : The number of characters copied is limited by "count".
002481  002682  //       : The terminating null character in destination is overwritten by
002482  002683  //       : the first character of source, and a new null-character is appended
002483  002684  //       : at the end of the new string formed by the concatenation of both in destination.
002484  002685  //       : returns destination.
002485  002686        
002486  002687        
002487  002688  func sys_StoreTouchCalibration(), 1;
002488  002689  // Syntax: sys_StoreTouchCalibration();
002489  002690  // Usage : r := sys_StoreTouchCalibration();
002490  002691  // Notes : Store the touch calibration values in non-volatile memory.
002491  002692  //       : Returns true if the values have been accepted and stored,
002492  002693  //       : else returns false if write could not be performed, or
002493  002694  //       : touch calibration values are improbable.
002494  002695  //       : The values that are stored are obtained from:-
002495  002696  //     : TOUCH_XMINCAL             78  // touch calibration value
002496  002697  //     : TOUCH_YMINCAL             79  // touch calibration value
002497  002698  //       : TOUCH_XMAXCAL             80  // touch calibration value
002498  002699  //       : TOUCH_YMAXCAL             81  // touch calibration value
002499  002700  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002500  002701  //       : This function is not supported on uVGA, Capicitive touch
002501  002702  //       : and 4.3" resistive touch modules.
002502  002703        
002503  002704        
002504  002705  func unicode_page("charbeg","charend","charoffset"), 1;
002505  002706  // Syntax: unicode_page("charbeg","charend","charoffset");
002506  002707  // Usage : eg:  F_Traditional_0x20_0xFF
002507  002708  // Notes : After selecting a unicode image control with txt_FontID,
002508  002709  //       : this function is called to set the required font within the
002509  002710  //       : unicode set. The file "Unicode.inc" contains wrappers for
002510  002711  //       : this function, and it is not normally called directly.
002511  002712  //       : Returns count of characters in the set.
002512  002713  //       : Refer to "Unicode.inc" for further information.
002513  002714        
002514  002715        
002515  002716  func EVE_SP(), 1;
002516  002717  // Syntax: EVE_SP();
002517  002718  // Usage : eg:  print(EVE_SP());
002518  002719  // Notes : Used for debugging to assess the current stack level,
002519  002720  //       : mainly for checking stack leaks
002520  002721        
002521  002722  func EVE_SSIZE(), 1;
002522  002723  // Syntax: EVE_SSIZE();
002523  002724  // Usage : eg:  print(EVE_SSIZE());
002524  002725  // Notes : Used to get the stack size,
002525  002726  //       : mainly for debugging purposes
002526  002727        
002527  002728        
002528  002729  // uVGAII extended functions
002529  002730  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002530  002731  // Syntax: disp_Sync(line);
002531  002732  // Usage : disp_Sync(480);
002532  002733  // Notes : Waits till the hardware gets to a certain line.
002533  002734  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002534  002735  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002535  002736  //       : depending on the graphics operation. The higher the value, the slower
002536  002737  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002537  002738  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002538  002739  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002539  002740  //       : be slowest (as its actually right at the end of the blanking period) and 508
002540  002741  //       : will cause a hangup situation as it is above the highes scanline value.
002541  002742  //       : Currently, this function is only supported on displays with SSD1963 driver.
002542  002743        
002543  002744        
002544  002745  // New functions added to PmmC v2.8
002545  002746  //================================================================
002546  002747  func CY(), 1;
002547  002748  // Syntax: CY();
002548  002749  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002549  002750  //       : print(myvar," "CY(),"\n");           // carry = 1
002550  002751  // Notes : This function returns the carry status of an
002551  002752  // unsigned overflow from any 16 or 32bit additions or sutractions.
002552  002753  //================================================================
002553  002754        
002554  002755        
002555  002756  //================================================================
002556  002757  func str_ByteMove("src", "dest", "count"), 1;
002557  002758  // func str_ByteMove("src", "dest", "count"), 1;
002558  002759  // Syntax   : str_ByteMove(src, dest, bytecount);
002559  002760  // Input    : STR *source points to byte aligned source.
002560  002761  //          : STR *dest   points to byte aligned destination.
002561  002762  //          : VAR count   number of bytes to transfer.
002562  002763  // Usage    : nextpos := str_ByteMove(s, d, 100);
002563  002764  // Notes    : copy bytes from "src" to "dest", stopping only
002564  002765  //          : when "count" is exhausted.
002565  002766  //          : No terminator is appended, it is purely a
002566  002767  //          : byte copy, and any zeroes encountered will
002567  002768  //          : also be copied.
002568  002769  // Returns  : returns a pointer to the end of the destination
002569  002770  //          : (which is "dest" + "count")
002570  002771  //================================================================
002571  002772        
002572  002773        
002573  002774  //================================================================
002574  002775  func str_Copy("dest", "src"), 1;
002575  002776  // Syntax   : str_Copy(dest, src);
002576  002777  // Input    : STR *dest   points to byte aligned destination.
002577  002778  //          : STR *source points to byte aligned source.
002578  002779  // Usage    : nextplace := str_Copy(d, s);
002579  002780  // Notes    : copy a string from "src" to "dest", stopping only
002580  002781  //          : when the end of source string "src" is encountered
002581  002782  //          : (0x00 terminator).
002582  002783  //          : The terminator is always appended, even if "src" is
002583  002784  //          : an empty string.
002584  002785  // Returns  : returns a pointer to the 0x00 string terminator at
002585  002786  //          : end of "dest" (which is "dest" + str_Length(src); )
002586  002787  //================================================================
002587  002788        
002588  002789  //================================================================
002589  002790  func str_CopyN("dest", "src", "count"), 1;
002590  002791  // Syntax   : str_CopyN(dest, src, bytecount);
002591  002792  // Input    : STR *dest   points to byte aligned destination.
002592  002793  //          : STR *source points to byte aligned source.
002593  002794  //          : VAR count   max number of chars to copy.
002594  002795  // Usage    : nextplace := str_CopyN(d, s, 100);
002595  002796  // Notes    : copy a string from "src" to "dest", stopping only
002596  002797  //          : when "count" is exhausted, or end of source
002597  002798  //          : string "str" is encountered (0x00 string terminator).
002598  002799  //          : The terminator is always appended, even if
002599  002800  //          : "count" is zero, or "src" is a null string.
002600  002801  // Returns  : returns a pointer to the 0x00 string terminator
002601  002802  //          : (which is "dest" + whatever was copied)
002602  002803  //================================================================
002603  002804        
002604  002805  //================================================================
002605  002806  func umul_1616("&res32", "val1", "val2"), 1;
002606  002807  // Syntax   : umul_1616(&res32, varA, varB);
002607  002808  // Input    : DWORD *result   points to 32bit result register.
002608  002809  //          : VAR   val1  16bit register or constant
002609  002810  //          : VAR   val2  16bit register or constant
002610  002811  // Usage    : var res32[2];
002611  002812  //          : umul_1616(&res32, myvar, 50000);
002612  002813  // Notes    : performs an unsigned multiply of 2 x 16bit values
002613  002814  //          : placing the 32bit result in a 2 word array.
002614  002815  // Returns  : the pointer to the 32bit result.
002615  002816  //          : carry and overflow are not affected.
002616  002817  //================================================================
002617  002818        
002618  002819  //================================================================
002619  002820  func uadd_3232("&res32", "&val1", "&val2"), 1;
002620  002821  // Syntax   : cmp_3232(&res32, &varA, &varB);
002621  002822  // Input    : DWORD *res32 points to optional result (or zero for compare)
002622  002823  //          : DWORD *val1 points to 32bit augend
002623  002824  //          : DWORD *val2 points to 32bit addend
002624  002825  // Usage    : var res32[2];
002625  002826  //          : res := cmp_3232(res32, val1, val2);
002626  002827  // Notes    : performs an unsigned addition of 2 x 32bit values
002627  002828  //          : placing the 32bit result in a 2 word array.
002628  002829  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002629  002830  //          ; carry flag is also set on 32bit unsigned overflow
002630  002831  //          ; and can be read with the CY() function.
002631  002832  //================================================================
002632  002833        
002633  002834  //================================================================
002634  002835  func usub_3232("&res32", "&val1", "&val2"), 1;
002635  002836  // Syntax   : cmp_3232(&res32, &varA, &varB);
002636  002837  // Input    : DWORD *res32 points to optional result (or zero for compare)
002637  002838  //          : DWORD *val1 points to first 32bit minuend
002638  002839  //          : DWORD *val2 points to 32bit subtrahend
002639  002840  // Usage    : var res32[2];
002640  002841  //          : res := cmp_3232(res32, val1, val2);
002641  002842  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002642  002843  //          : placing the 32bit result in a 2 word array.
002643  002844  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002644  002845  //          ; carry flag is also set on 32bit unsigned underflow
002645  002846  //          ; and can be read with the CY() function.
002646  002847  //================================================================
002647  002848        
002648  002849  //================================================================
002649  002850  func ucmp_3232("&val1", "&val2"), 1;
002650  002851  // Syntax   : cmp_3232(&varA, &varB);
002651  002852  // Input    : DWORD *val1 points to 32bit minuend
002652  002853  //          : DWORD *val2 points to 32bit sutrahend
002653  002854  // Usage    : res := cmp_3232(val1, val2);
002654  002855  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002655  002856  //          : The result of the subtraction is returned.
002656  002857  // Returns  : 0  if equal
002657  002858  //          : 1  if val1 > val2
002658  002859  //          : -1 if val1 < val2
002659  002860  //          : This function does not affect the carry flag.
002660  002861  //================================================================
002661  002862        
002662  002863  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002663  002864  // Syntax: disp_Disconnect();                  New in v3.8
002664  002865  // Usage : disp_Disconnect();
002665  002866  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002666  002867  //       : its lowest possible power consumption. Use after disabling peripheral power
002667  002868  //       : to ensure the minimal power usage by the display.
002668  002869  //       : disp_Init() should be used to reinitialise the display.
002669  002870        
002670  002871  func reserved(), 0;                            
002671  002872        
002672  002873  func sys_DeepSleep("units"), 1;
002673  002874  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002674  002875  // Usage : t := sys_DeepSleep(10);
002675  002876  // Notes : sets the display and processor into lowest power mode for a period of time.
002676  002877  //       : When returning from DeepSleep the display should be reinitialised
002677  002878  //       : with disp_Init().
002678  002879  //       : Touching the touch screen will also wake from sleep.
002679  002880  //       : Returns remaining sleep units.
002680  002881        
002681  002882  //------------------------------------------------------------------//
002682  002883  // CONSTANTS
002683  002884  //------------------------------------------------------------------//
002684  002885        
002685  002886  // generic constants
002686  002887  #CONST
002687  002896  #END
002688  002897        
002689  002898  //------------------------------------------------------------------------------
002690  002899  // Pin related constants
002691  002900  //------------------------------------------------------------------------------
002692  002901  #CONST
002693  002919  #END
002694  002920        
002695  002921  //------------------------------------------------------------------------------
002696  002922  //gfx_Set() related constants
002697  002923  //------------------------------------------------------------------------------
002698  002924  #CONST
002699  002941  #END
002700  002942        
002701  002943        
002702  002944  //gfx_Get() related constants
002703  002945  #CONST
002704  002954  #END
002705  002955        
002706  002956        
002707  002957        
002708  002958        
002709  002959  #CONST
002710  002972  #END
002711  002973        
002712  002974        
002713  002975  #CONST
002714  002998  #END
002715  002999        
002716  003000  //------------------------------------------------------------------------------
002717  003001  //txt_Set() related constants
002718  003002  //------------------------------------------------------------------------------
002719  003003  #CONST
002720  003022  #END
002721  003023        
002722  003024        
002723  003025        
002724  003026  //------------------------------------------------------------------------------
002725  003027  //txt_Set() related arguments
002726  003028  // NB:- FONT4 must be inherited if required,
002727  003029  // eg #inherit "FONT4.fnt"
002728  003030  //------------------------------------------------------------------------------
002729  003031  #CONST
002730  003043  #END
002731  003044        
002732  003045        
002733  003046        
002734  003047  //touch_Set() related constants
002735  003048  #CONST
002736  003052  #END
002737  003053        
002738  003054  //touch_Get() related constants
002739  003055  #CONST
002740  003063  #END
002741  003064        
002742  003065  // image control offset related constants
002743  003066  #CONST
002744  003073  #END
002745  003074        
002746  003075  // image attribute flags
002747  003076  // for img_SetAttributes(...) and img_ClearAttributes(...)
002748  003077  #CONST
002749  003091  #END
002750  003092        
002751  003093        
002752  003094  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002753  003094  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002754  003095        
002755  003096  // image control entry offsets
002756  003097  #CONST
002757  003112  #END
002758  003113        
002759  003114  #CONST
002760  003132  #END
002761  003133        
002762  003134        
002763  003135        
002764  003136        
002765  003137  #CONST
002766  003157  #END
002767  003158        
002768  003159        
002769  003160        
002770  003161  // timer control  related constants
002771  003162  #CONST
002772  003171  #END
002773  003172        
002774  003173  // I2C timing related constants
002775  003174  #CONST
002776  003178  #END
002777  003179        
002778  003180        
002779  003181  // spi_Init(...)  mode arguments
002780  003182  #CONST
002781  003192  #END
002782  003193        
002783  003194  //------------------------------------------------------------------------------
002784  003195  // system WORD variables accesible with peekW and pokeW or pointer access
002785  003196  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002786  003197  // can also be accessed with peekW and pokeW
002787  003198  //------------------------------------------------------------------------------
002788  003199        
002789  003200  #CONST
002790  003294  #END
002791  003295        
002792  003296  //------------------------------------------------------------------------------
002793  003297  // FILEIO Error Code Constants
002794  003298  //------------------------------------------------------------------------------
002795  003299  #CONST
002796  003325  #END
002797  003326        
002798  003327  //==================================================================================================
002799  003328        
002800  003329        
002801  003330        
002802  000013      #ENDIF
002803  000014        
002804  000015        
002805  000016      #CONST
002806  000072      #END
002807  000073        
002808  000074        
002809  000075  //===========================================================================================
002810  000076        
002811  000077        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002812  000016  #inherit "4DGL_16bitColours.fnc"
002813  000016  #inherit "4DGL_16bitColours.fnc"
002814  000004  */
002815  000005        
002816  000006        
002817  000007        
002818  000008  #CONST
002819  000149  #END
002820  000150        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\VisualConst.inc

002821  000017  #inherit "VisualConst.inc"
002822  000017  #inherit "VisualConst.inc"
002823  000001  // Line Patterns
002824  000002  #constant  LPCOARSE    0xF0F0
002825  000002  #constant  LPCOARSE    0xF0F0
002826  000003  #constant  LPMEDIUM    0x3333
002827  000003  #constant  LPMEDIUM    0x3333
002828  000004  #constant  LPFINE      0xAAAA
002829  000004  #constant  LPFINE      0xAAAA
002830  000005  #constant  LPDASHDOT   0x03CF
002831  000005  #constant  LPDASHDOT   0x03CF
002832  000006  #constant  LPDASHDOTDOT 0x0333
002833  000006  #constant  LPDASHDOTDOT 0x0333
002834  000007  #constant  LPSOLID     0x0000
002835  000007  #constant  LPSOLID     0x0000
file C:\Users\lvlg\Desktop\TEST_AFF_PICASO\NoName1.4DWork\NoName1Const.inc

002836  000018  #inherit "NoName1Const.inc"
002837  000018  #inherit "NoName1Const.inc"
002838  000001  // File generated 2024-02-09 14:54:03
002839  000002  // Warning! This is a generated file, any manual changes will be
002840  000003  // lost during the next generation.
002841  000004        
002842  000005  #constant  IFONT_OFFSET     0
002843  000005  #constant  IFONT_OFFSET     0
002844  000006  // object indexes into ImageControl
002845  000007  #CONST
002846  000011  #END
002847  000012        
002848  000013        
002849  000014  #IFNOT EXISTS NOGLOBALS
002850  000015  var hndl ;
002851  000016  #ENDIF
002852  000019        
002853  000020        
002854  000021  func main()
002855  000022        
002856  000023      // state :     tat de l'cran tactile
002857  000024      // x :         valeur en x de l'cran tactile
002858  000025      // n :         Pour darder l'ID de la switch
002859  000026      // DIPstate: tat de la switch
002860  000027      var state, x, n, DIPstate;
002861  000028        
002862  000029        
002863  000034      */
002864  000035      putstr("Mounting...\n");
002865  000036      if (!(file_Mount()))
002866  000037          while(!(file_Mount()))
002867  000038              putstr("Drive not mounted...");
002868  000039              pause(200);
002869  000040              gfx_Cls();
002870  000041              pause(200);
002871  000042          wend
002872  000043      endif
002873  000044        
002874  000045        
002875  000046      // Affiche "HELLO!!!!!" sur l'cran.
002876  000047      print("HELLO!!!!!\n\r");
002877  000048        
002878  000049      // Charge les fichiers "NoName1.dat" et "NoName1.gci" qui contiennent les widgets.
002879  000050      hndl := file_LoadImageControl("NoName1.dat", "NoName1.gci", 1);
002880  000051        
002881  000052      // Le sens de l'cran
002882  000053      gfx_Set(SCREEN_MODE,LANDSCAPE) ;
002883  000054        
002884  000055        
002885  000056      // Cration du widget switch
002886  000057      img_ClearAttributes(hndl, iDipswitch1, I_TOUCH_DISABLE);
002887  000058      img_SetWord(hndl, iDipswitch1, IMAGE_INDEX, 0) ;
002888  000059        
002889  000060      // Affiche le widget switch sur l'cran
002890  000061      img_Show(hndl,iDipswitch1) ;
002891  000062        
002892  000063      // Le label affiche "HELLO"
002893  000064      img_Show(hndl,"HELLO") ;
002894  000065        
002895  000066        
002896  000067      // Cre et affiche un thermomtre
002897  000068      img_SetWord(hndl, iThermometer1, IMAGE_INDEX, 50) ;
002898  000069      img_Show(hndl,iThermometer1) ;
002899  000070        
002900  000071        
002901  000072      // Active l'cran tactile
002902  000073      touch_Set(TOUCH_ENABLE);
002903  000074        
002904  000075      // Valeur initiale de la switch
002905  000076      DIPstate := 0;
002906  000077        
002907  000078        
002908  000079      // quivalant d'un While
002909  000080      repeat
002910  000081        
002911  000082      // Prends l'tat de l'cran tactile
002912  000083      state := touch_Get(TOUCH_STATUS);
002913  000084        
002914  000085      // Si on arrte de toucher l'cran tactile
002915  000086      if(state == TOUCH_RELEASED)
002916  000087          gfx_Cls();                        // fface l'cran
002917  000088          x := touch_Get(TOUCH_GETX);        // Prends la dernire position en X
002918  000089          print("X =  ");                    // Affiche la valeur de X
002919  000090          print(x);
002920  000091          img_Show(hndl,x) ;                // Le label affiche la valeur de X
002921  000092          print("\r");
002922  000093          n := img_Touched(hndl, iDipswitch1);    // Prends le "ID" de la switch si elle est touche
002923  000094        
002924  000095          // Si le ID est celle de la switch
002925  000096          if(n == iDipswitch1)
002926  000097        
002927  000100                       et la switch avec les nouvelles valeures.       */
002928  000101                  if(DIPstate == 0)
002929  000102                      DIPstate := 1;
002930  000103                      img_SetWord(hndl, iDipswitch1, IMAGE_INDEX, DIPstate);
002931  000104                      img_SetWord(hndl, iThermometer1, IMAGE_INDEX, 10) ;
002932  000105                      img_Show(hndl,iDipswitch1) ;
002933  000106                      img_Show(hndl,iThermometer1) ;
002934  000107                  else
002935  000108                      DIPstate := 0;
002936  000109                      img_SetWord(hndl, iDipswitch1, IMAGE_INDEX, DIPstate);
002937  000110                      img_SetWord(hndl, iThermometer1, IMAGE_INDEX, 100) ;
002938  000111                      img_Show(hndl,iDipswitch1) ;
002939  000112                      img_Show(hndl,iThermometer1) ;
002940  000113                  endif
002941  000114          endif
002942  000115      endif
002943  000116        
002944  000117      forever
002945  000118  endfunc
002946  000119        


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (not used)
BACKLITE                               6  0x00000006 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (not used)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
C:\Users\lvlg\Desktop\TEST_AFF_PICASO\NoName1.4dg    2806  0x00000af6 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COLUMN_ADDRESS_END1                    5  0x00000005 (const dword)  (not used)
COLUMN_ADDRESS_END2                    4  0x00000004 (const dword)  (not used)
COLUMN_ADDRESS_START1                  3  0x00000003 (const dword)  (not used)
COLUMN_ADDRESS_START2                  2  0x00000002 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (not used)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (not used)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (not used)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
CYCLE_CONTROL_1                       58  0x0000003a (const dword)  (not used)
CYCLE_CONTROL_2                       59  0x0000003b (const dword)  (not used)
CYCLE_CONTROL_3                       60  0x0000003c (const dword)  (not used)
CYCLE_CONTROL_4                       61  0x0000003d (const dword)  (not used)
CYCLE_CONTROL_5                       62  0x0000003e (const dword)  (not used)
CYCLE_CONTROL_6                       64  0x00000040 (const dword)  (not used)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DISPLAY_CONTROL_1                     38  0x00000026 (const dword)  (not used)
DISPLAY_CONTROL_10                    54  0x00000036 (const dword)  (not used)
DISPLAY_CONTROL_14                    65  0x00000041 (const dword)  (not used)
DISPLAY_CONTROL_2                     39  0x00000027 (const dword)  (not used)
DISPLAY_CONTROL_3                     40  0x00000028 (const dword)  (not used)
DISPLAY_CONTROL_4                     41  0x00000029 (const dword)  (not used)
DISPLAY_CONTROL_5                     42  0x0000002a (const dword)  (not used)
DISPLAY_CONTROL_6                     44  0x0000002c (const dword)  (not used)
DISPLAY_CONTROL_7                     45  0x0000002d (const dword)  (not used)
DISPLAY_CONTROL_8                    144  0x00000090 (const dword)  (not used)
DISPLAY_CONTROL_9                     53  0x00000035 (const dword)  (not used)
DISPLAY_MODE_CONTROL                   1  0x00000001 (const dword)  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DOWN                                   0  0x00000000 (const dword)  (not used)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (not used)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (not used)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (not used)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (not used)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (not used)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (not used)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (not used)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAMMA_CONTROL_1                       70  0x00000046 (const dword)  (not used)
GAMMA_CONTROL_10                      79  0x0000004f (const dword)  (not used)
GAMMA_CONTROL_11                      80  0x00000050 (const dword)  (not used)
GAMMA_CONTROL_12                      81  0x00000051 (const dword)  (not used)
GAMMA_CONTROL_2                       71  0x00000047 (const dword)  (not used)
GAMMA_CONTROL_3                       72  0x00000048 (const dword)  (not used)
GAMMA_CONTROL_4                       73  0x00000049 (const dword)  (not used)
GAMMA_CONTROL_5                       74  0x0000004a (const dword)  (not used)
GAMMA_CONTROL_6                       75  0x0000004b (const dword)  (not used)
GAMMA_CONTROL_7                       76  0x0000004c (const dword)  (not used)
GAMMA_CONTROL_8                       77  0x0000004d (const dword)  (not used)
GAMMA_CONTROL_9                       78  0x0000004e (const dword)  (not used)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (not used)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (not used)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (not used)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (not used)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (not used)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 6)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (not used)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (not used)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (not used)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (not used)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (not used)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (not used)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (not used)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 3)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (not used)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (not used)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (not used)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
hndl                                   0  0x00000000 (mem) word (global)  (usage 51)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (not used)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (not used)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (not used)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (not used)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (not used)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (not used)
I2C_SLOW                               0  0x00000000 (const dword)  (not used)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (not used)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (not used)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (not used)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (not used)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (not used)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (usage 3)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
iDipswitch1                            1  0x00000001 (const ??? 0)  (usage 27)
IFONT_OFFSET                           0  0x00000000 (const dword)  (not used)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 18)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_TAG                             12  0x0000000c (const dword)  (not used)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (usage 3)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (not used)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (not used)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (not used)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (not used)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 18)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 24)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (usage 3)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
iStatictext1                           2  0x00000002 (const ??? 0)  (not used)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
iThermometer1                          0  0x00000000 (const ??? 0)  (usage 18)
IVORY                              65534  0x0000fffe (const dword)  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 3)
LANDSCAPE_R                            1  0x00000001 (const dword)  (not used)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPCOARSE                           61680  0x0000f0f0 (const dword)  (not used)
LPDASHDOT                            975  0x000003cf (const dword)  (not used)
LPDASHDOTDOT                         819  0x00000333 (const dword)  (not used)
LPFINE                             43690  0x0000aaaa (const dword)  (not used)
LPMEDIUM                           13107  0x00003333 (const dword)  (not used)
LPSOLID                                0  0x00000000 (const dword)  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                  90  0x0000005a (User func) args[0] r=0  (not used)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (not used)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (not used)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MEMORY_ACCESS_CONTROL                 22  0x00000016 (const dword)  (not used)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
OFF                                    0  0x00000000 (const dword)  (not used)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (not used)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OSC_CONTROL_1                         25  0x00000019 (const dword)  (not used)
OSC_CONTROL_3                        147  0x00000093 (const dword)  (not used)
OUTLINE                                1  0x00000001 (const dword)  (not used)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 6)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (not used)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
POWER_CONTROL_1                       27  0x0000001b (const dword)  (not used)
POWER_CONTROL_2                       28  0x0000001c (const dword)  (not used)
POWER_CONTROL_3                       29  0x0000001d (const dword)  (not used)
POWER_CONTROL_4                       30  0x0000001e (const dword)  (not used)
POWER_CONTROL_5                       31  0x0000001f (const dword)  (not used)
POWER_CONTROL_6                       32  0x00000020 (const dword)  (not used)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_WRITE_DATA                       34  0x00000022 (const dword)  (not used)
RED                                63488  0x0000f800 (const dword)  (not used)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
RGBINT_CONTROL_1                      56  0x00000038 (const dword)  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROW_ADDRESS_END1                       9  0x00000009 (const dword)  (not used)
ROW_ADDRESS_END2                       8  0x00000008 (const dword)  (not used)
ROW_ADDRESS_START1                     7  0x00000007 (const dword)  (not used)
ROW_ADDRESS_START2                     6  0x00000006 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RUNFLASH                             128  0x00000080 (const dword)  (not used)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
SCREEN_MODE                           23  0x00000017 (const dword)  (usage 3)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (not used)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (not used)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (not used)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (not used)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (not used)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (not used)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (not used)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (not used)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (not used)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (not used)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (not used)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (not used)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (not used)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (not used)
TIMER2                                 2  0x00000002 (const dword)  (not used)
TIMER3                                 3  0x00000003 (const dword)  (not used)
TIMER4                                 4  0x00000004 (const dword)  (not used)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (not used)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (not used)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 6)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 3)
TOUCH_GETY                             2  0x00000002 (const dword)  (not used)
TOUCH_MOVING                           3  0x00000003 (const dword)  (not used)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (not used)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 3)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (not used)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (not used)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
ULCD_32PT_GFX                          0  0x00000000 (const ??? 0)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (not used)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
VCOM_CONTROL_1                        67  0x00000043 (const dword)  (not used)
VCOM_CONTROL_2                        68  0x00000044 (const dword)  (not used)
VCOM_CONTROL_3                        69  0x00000045 (const dword)  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (not used)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
